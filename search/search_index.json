{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The APTrust Registry The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests. Note This documentation is not meant to be exhaustive, nor is it meant to show users how to use the Registry. This documentation intends to provide an overview to developers who will maintain Registry code. While the code itself contains detailed comments where necessary, these pages give you a high-level view of the system's main components, their roles, where they can be found, and how they interact. External Components & Services The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"Home"},{"location":"#the-aptrust-registry","text":"The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests. Note This documentation is not meant to be exhaustive, nor is it meant to show users how to use the Registry. This documentation intends to provide an overview to developers who will maintain Registry code. While the code itself contains detailed comments where necessary, these pages give you a high-level view of the system's main components, their roles, where they can be found, and how they interact.","title":"The APTrust Registry"},{"location":"#external-components-services","text":"The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"External Components &amp; Services"},{"location":"components/","text":"Code Components The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages. The Application File The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries. Template Helpers The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go Constants constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied. The Configuration Object The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below. The Context Object The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message. Security Middleware Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle. The Request Object The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.) The Pager The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it. Custom Forms The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form . Views Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup. Models The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM. Web and API Handlers All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file . UI Components Page The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"Key Code Components"},{"location":"components/#code-components","text":"The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages.","title":"Code Components"},{"location":"components/#the-application-file","text":"The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries.","title":"The Application File"},{"location":"components/#template-helpers","text":"The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go","title":"Template Helpers"},{"location":"components/#constants","text":"constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied.","title":"Constants"},{"location":"components/#the-configuration-object","text":"The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below.","title":"The Configuration Object"},{"location":"components/#the-context-object","text":"The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message.","title":"The Context Object"},{"location":"components/#security-middleware","text":"Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle.","title":"Security Middleware"},{"location":"components/#the-request-object","text":"The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.)","title":"The Request Object"},{"location":"components/#the-pager","text":"The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it.","title":"The Pager"},{"location":"components/#custom-forms","text":"The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form .","title":"Custom Forms"},{"location":"components/#views","text":"Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup.","title":"Views"},{"location":"components/#models","text":"The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM.","title":"Models"},{"location":"components/#web-and-api-handlers","text":"All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file .","title":"Web and API Handlers"},{"location":"components/#ui-components-page","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"UI Components Page"},{"location":"database/","text":"The Registry Database Registry uses a Postgres database, which runs in RDS in our live environments. You'll find connection settings in the .env files, such as .env.test for non-live environments, and in AWS Parameter Store for live environments. The database was converted from the old Pharos DB. An overview of the migrations is available in this README . You can generate the current schema by loading the initial launch schema and then running the migrations on top of that. This is what happens when you run the registry test suite with the ./registry test command. Under the hood, the test suite calls a set of functions in db/testutil.go to do the following: drop all objects in the database load the initial launch schema run all migrations in the db/migrations folder load fixtures for testing Migrations We are currently not using any migration manager. We write migrations as pure idempotent SQL and run them manually from the staging/demo/production bastion server. We'll look into better migration management solutions in the future. It's essential, however, to write idempotent migrations so that re-running a migration will not corrupt or damage the database. Note The migration files are well commented. Look there if you're interested in details of what's going on and why things were written the way they were. Migration Patterns Migration files are SQL files in the db/migrations directory. They are named in the order they should be run. For example, 001_deposit_stats.sql runs before 002_work_item_restorations.sql. Each migration begins by setting a started_at timestamp in the schema_migrations table and ends by setting a finished_at timestamp. Views The database uses views for most of Registry's detail and list pages. The old Pharos application used Rails and ActiveRecord to define relations, and typically issued many queries to assemble the data that the new DB assembles in views. Views allow Registry to issue single queries where Rails issued multiple queries. Materialized Views The database includes a number of materialized views to hold statistics that are expensive to calculate. The include counts and sums from large tables. The views are populated hourly by three SQL functions in db/migrations/001_deposit_stats.sql . These functions are intelligent enough to avoid unnecessary work. They are called by Registry itself every hour or so. When Registry starts, it creates a single Context object whose initializer calls initCronJobs() . That runs the update functions in common/cron.go every hour or so.","title":"Database"},{"location":"database/#the-registry-database","text":"Registry uses a Postgres database, which runs in RDS in our live environments. You'll find connection settings in the .env files, such as .env.test for non-live environments, and in AWS Parameter Store for live environments. The database was converted from the old Pharos DB. An overview of the migrations is available in this README . You can generate the current schema by loading the initial launch schema and then running the migrations on top of that. This is what happens when you run the registry test suite with the ./registry test command. Under the hood, the test suite calls a set of functions in db/testutil.go to do the following: drop all objects in the database load the initial launch schema run all migrations in the db/migrations folder load fixtures for testing","title":"The Registry Database"},{"location":"database/#migrations","text":"We are currently not using any migration manager. We write migrations as pure idempotent SQL and run them manually from the staging/demo/production bastion server. We'll look into better migration management solutions in the future. It's essential, however, to write idempotent migrations so that re-running a migration will not corrupt or damage the database. Note The migration files are well commented. Look there if you're interested in details of what's going on and why things were written the way they were.","title":"Migrations"},{"location":"database/#migration-patterns","text":"Migration files are SQL files in the db/migrations directory. They are named in the order they should be run. For example, 001_deposit_stats.sql runs before 002_work_item_restorations.sql. Each migration begins by setting a started_at timestamp in the schema_migrations table and ends by setting a finished_at timestamp.","title":"Migration Patterns"},{"location":"database/#views","text":"The database uses views for most of Registry's detail and list pages. The old Pharos application used Rails and ActiveRecord to define relations, and typically issued many queries to assemble the data that the new DB assembles in views. Views allow Registry to issue single queries where Rails issued multiple queries.","title":"Views"},{"location":"database/#materialized-views","text":"The database includes a number of materialized views to hold statistics that are expensive to calculate. The include counts and sums from large tables. The views are populated hourly by three SQL functions in db/migrations/001_deposit_stats.sql . These functions are intelligent enough to avoid unnecessary work. They are called by Registry itself every hour or so. When Registry starts, it creates a single Context object whose initializer calls initCronJobs() . That runs the update functions in common/cron.go every hour or so.","title":"Materialized Views"},{"location":"deletion/","text":"File and Object Deletion File and object deletion follow the same multi-step process: An institutional user or institution admin clicks the Delete button on an object or file detail page. This creates a deletion request in the Registry database. Registry sends an email to administrators at the institution, telling them that a deletion request awaits their review. The email includes a link and a token to review the request. The institutional admin either approves or denies the request. If denied, processing stops there. If approved, we move on to step 4. Registry creates a WorkItem for the deletion request and adds the WorkItem ID to NSQ's delete_item topic. From there, the worker will double-check to ensure the deletion request was approved, and will then delete the files from long-term perservation, change their state from A (active) to D (deleted), and create the required Deletion PREMIS events. Registry's back-end includes safegaurds to prevent non-institutional admins from approving deletions. APTrust admins can view deletion requests but cannot approve them, even accidentally. Institutional users cannot approve deletion requests, nor can admins from institutions that don't own the files/objects to be deleted.","title":"Deletion"},{"location":"deletion/#file-and-object-deletion","text":"File and object deletion follow the same multi-step process: An institutional user or institution admin clicks the Delete button on an object or file detail page. This creates a deletion request in the Registry database. Registry sends an email to administrators at the institution, telling them that a deletion request awaits their review. The email includes a link and a token to review the request. The institutional admin either approves or denies the request. If denied, processing stops there. If approved, we move on to step 4. Registry creates a WorkItem for the deletion request and adds the WorkItem ID to NSQ's delete_item topic. From there, the worker will double-check to ensure the deletion request was approved, and will then delete the files from long-term perservation, change their state from A (active) to D (deleted), and create the required Deletion PREMIS events. Registry's back-end includes safegaurds to prevent non-institutional admins from approving deletions. APTrust admins can view deletion requests but cannot approve them, even accidentally. Institutional users cannot approve deletion requests, nor can admins from institutions that don't own the files/objects to be deleted.","title":"File and Object Deletion"},{"location":"institution-management/","text":"Institution Management APTrust admins can add, edit, and delete institutions. No other roles can do this. Note that deleting an instituion does not remove the institution's records from the database, nor does it affect their files in preservation storage. It simply marks the institution as inactive, and prevents their users from logging in. This action is reversible. Un-deleting an institution changes it's state back to Active and allows their users to log in. You can manage institutions from the Institutions link in the Registry's left nav bar.","title":"Institution Management"},{"location":"institution-management/#institution-management","text":"APTrust admins can add, edit, and delete institutions. No other roles can do this. Note that deleting an instituion does not remove the institution's records from the database, nor does it affect their files in preservation storage. It simply marks the institution as inactive, and prevents their users from logging in. This action is reversible. Un-deleting an institution changes it's state back to Active and allows their users to log in. You can manage institutions from the Institutions link in the Registry's left nav bar.","title":"Institution Management"},{"location":"models/","text":"Data Models The data models that form the core of the Registry are located in the pgmodels directory . These models map directly to database tables or database views. Table-backed models support inserts and usually updates and deletions. (Some records, such as PREMIS events, cannot be updated or deleted.) Most models implementing deletion support soft-deletion only. View-backed models are read-only. These are generally used to gather data for detail and list pages with a single query. The Base Model The base models, BaseModel and TimestampModel, are defined in pgmodels/pgmodel.go , which also defines base methods for insertion, updating, and transactions. This file has two other important functions: initFilters() defines a whitelist of allowed filters for each model type. InstIDFor() returns the ID of the insitution that owns any given resource. InstIDFor() is especially important for the security checks run by the resource authorization middleware , which checks permissions against roles and ensures institutional users and admins can access only those resources belonging to their own institutions. Allowed Filters Each model defines a list of allowed filters that users can use to refine results in list queries. The filters are often defined on the view version of a model. For example, pgmodels/work_item_view.go defines a number of filters for the WorkItem list. These filters become the names of form controls in the related filter form. See, for example, the WorkItemFilterForm . That form will be rendered by the work item filters view . When a user submits a query to the WorkItem list page, the GetFilterCollection() function of the web request object parses the query string into a FilterCollection object , whose ToQuery() function converts it to a Query object . The effect of all this is that we can add new query fields for any table or view simply by adding items to the allowed filters list. As long as the filter name follows a defined pattern, the Registry code will know what to do with it. This system also ensures that Registry won't accept unknown or dangerous filters, only those that are whitelisted. The QueryOp map in pgmodels/query.go defines how filter name suffixes map to SQL operators. For example, query string parameters size=99 and size__eq=99 both turn into the SQL condition size = 99 . Similarly, size__gt=99 turns into size > 99 , while size__gteq=99 turns into size >= 99 . The QueryOp map supports numeric operators as well as string and boolean equality, ILIKE , IN , NOT IN , IS NULL and IS NOT NULL . List of Models Below is a list of models in the pgmodels directory, along with a brief description of each. For more information, click on a model name to view the souce. Model Description Alert An alert sent to one or more users. E.g. password-reset email, deletion request review notice, etc. AlertView Read-only model containing additional fields from records related to the alert. This is used for querying and display. Checksum A checksum record for an individual GenericFile. Checksums cannot be deleted or updated. ChecksumView Read-only model containing additional fields from records related to the checksum. This is used for querying and display. Counts Includes several objects used to represent object, file, event, and work item counts. DeletionRequest Contains information about a request to delete a GenericFile or IntellectualObject. DeletionRequestView Read-only model containing additional fields from records related to the deletion request. This is used for querying and display. DepositFormatStats Contains stats about an institution's deposits. Possibly obsolete. This may have been superseded by DepositStats. DepositStats Contains repository-wide stats used in Registry's Reports page. GenericFile Represents a single file in preservation storage. GenericFileView Read-only model containing additional fields from records related to the file. This is used for querying and display. Institution Describes an institution (aka depositor). InstitutionView Read-only model containing additional fields from records related to the institution. This is used for querying and display. IntellectualObject Represents an object in preservation storage. An IntellectualObject is a collection of GenericFiles, plus some metadata, such as Title, Access settings, etc. IntellectualObjectView Read-only model containing additional fields from records related to the object. This is used for querying and display. PremisEvent Describes an action that the system or one of its users has performed on an IntellectualObject or GenericFile. PREMIS events cannot be updated or deleted. PremisEventView Read-only model containing additional fields from records related to the event. This is used for querying and display. StorageRecord Describes where in preservation storage a file can be found. User A Registry User. UserView Read-only model containing additional fields from records related to the user. This is used for querying and display. WorkItem Describes a task that is, has been, or will be carried out by Preserv's ingest, restoration or deletion services. WorkItemView Read-only model containing additional fields from records related to the WorkItem. This is used for querying and display. List of Non-Model Objects in pgmodels The following files in the pgmodels folder are not models but are related to models and database access. File Description factory.go Like Rails' FactoryGirl, this file contains functions to generate model instances for unit and integration tests. filter_collection.go Contains information about filters a user wants to apply when querying a list of records. json_types.go Contains specially-defined serialization models for some pgmodel types. These are for cases in which some front-end component requires a custom (usually lightweight) serialization of an object. pgmodel.go Contains base fields and functions inherited by other pgmolde.s query.go Contains information necessary to generate a database query, including where clause, sorting, offsets, and limits. This can be constructed from a FilterCollection object, which in turn is parsed from query string params.","title":"Data Models"},{"location":"models/#data-models","text":"The data models that form the core of the Registry are located in the pgmodels directory . These models map directly to database tables or database views. Table-backed models support inserts and usually updates and deletions. (Some records, such as PREMIS events, cannot be updated or deleted.) Most models implementing deletion support soft-deletion only. View-backed models are read-only. These are generally used to gather data for detail and list pages with a single query.","title":"Data Models"},{"location":"models/#the-base-model","text":"The base models, BaseModel and TimestampModel, are defined in pgmodels/pgmodel.go , which also defines base methods for insertion, updating, and transactions. This file has two other important functions: initFilters() defines a whitelist of allowed filters for each model type. InstIDFor() returns the ID of the insitution that owns any given resource. InstIDFor() is especially important for the security checks run by the resource authorization middleware , which checks permissions against roles and ensures institutional users and admins can access only those resources belonging to their own institutions.","title":"The Base Model"},{"location":"models/#allowed-filters","text":"Each model defines a list of allowed filters that users can use to refine results in list queries. The filters are often defined on the view version of a model. For example, pgmodels/work_item_view.go defines a number of filters for the WorkItem list. These filters become the names of form controls in the related filter form. See, for example, the WorkItemFilterForm . That form will be rendered by the work item filters view . When a user submits a query to the WorkItem list page, the GetFilterCollection() function of the web request object parses the query string into a FilterCollection object , whose ToQuery() function converts it to a Query object . The effect of all this is that we can add new query fields for any table or view simply by adding items to the allowed filters list. As long as the filter name follows a defined pattern, the Registry code will know what to do with it. This system also ensures that Registry won't accept unknown or dangerous filters, only those that are whitelisted. The QueryOp map in pgmodels/query.go defines how filter name suffixes map to SQL operators. For example, query string parameters size=99 and size__eq=99 both turn into the SQL condition size = 99 . Similarly, size__gt=99 turns into size > 99 , while size__gteq=99 turns into size >= 99 . The QueryOp map supports numeric operators as well as string and boolean equality, ILIKE , IN , NOT IN , IS NULL and IS NOT NULL .","title":"Allowed Filters"},{"location":"models/#list-of-models","text":"Below is a list of models in the pgmodels directory, along with a brief description of each. For more information, click on a model name to view the souce. Model Description Alert An alert sent to one or more users. E.g. password-reset email, deletion request review notice, etc. AlertView Read-only model containing additional fields from records related to the alert. This is used for querying and display. Checksum A checksum record for an individual GenericFile. Checksums cannot be deleted or updated. ChecksumView Read-only model containing additional fields from records related to the checksum. This is used for querying and display. Counts Includes several objects used to represent object, file, event, and work item counts. DeletionRequest Contains information about a request to delete a GenericFile or IntellectualObject. DeletionRequestView Read-only model containing additional fields from records related to the deletion request. This is used for querying and display. DepositFormatStats Contains stats about an institution's deposits. Possibly obsolete. This may have been superseded by DepositStats. DepositStats Contains repository-wide stats used in Registry's Reports page. GenericFile Represents a single file in preservation storage. GenericFileView Read-only model containing additional fields from records related to the file. This is used for querying and display. Institution Describes an institution (aka depositor). InstitutionView Read-only model containing additional fields from records related to the institution. This is used for querying and display. IntellectualObject Represents an object in preservation storage. An IntellectualObject is a collection of GenericFiles, plus some metadata, such as Title, Access settings, etc. IntellectualObjectView Read-only model containing additional fields from records related to the object. This is used for querying and display. PremisEvent Describes an action that the system or one of its users has performed on an IntellectualObject or GenericFile. PREMIS events cannot be updated or deleted. PremisEventView Read-only model containing additional fields from records related to the event. This is used for querying and display. StorageRecord Describes where in preservation storage a file can be found. User A Registry User. UserView Read-only model containing additional fields from records related to the user. This is used for querying and display. WorkItem Describes a task that is, has been, or will be carried out by Preserv's ingest, restoration or deletion services. WorkItemView Read-only model containing additional fields from records related to the WorkItem. This is used for querying and display.","title":"List of Models"},{"location":"models/#list-of-non-model-objects-in-pgmodels","text":"The following files in the pgmodels folder are not models but are related to models and database access. File Description factory.go Like Rails' FactoryGirl, this file contains functions to generate model instances for unit and integration tests. filter_collection.go Contains information about filters a user wants to apply when querying a list of records. json_types.go Contains specially-defined serialization models for some pgmodel types. These are for cases in which some front-end component requires a custom (usually lightweight) serialization of an object. pgmodel.go Contains base fields and functions inherited by other pgmolde.s query.go Contains information necessary to generate a database query, including where clause, sorting, offsets, and limits. This can be constructed from a FilterCollection object, which in turn is parsed from query string params.","title":"List of Non-Model Objects in pgmodels"},{"location":"nsq/","text":"NSQ The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once. Definitions A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic. Pausing and Unpausing Topics Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons. Emptying Topics and Channels With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"NSQ"},{"location":"nsq/#nsq","text":"The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once.","title":"NSQ"},{"location":"nsq/#definitions","text":"A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic.","title":"Definitions"},{"location":"nsq/#pausing-and-unpausing-topics","text":"Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons.","title":"Pausing and Unpausing Topics"},{"location":"nsq/#emptying-topics-and-channels","text":"With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"Emptying Topics and Channels"},{"location":"redis/","text":"Redis Preservation Services workers use Redis to store interim processing data during ingest. Registry displays a summary of Redis data for WorkItems currently in progress. Only APTrust admins can see this data. The summary includes information about when each worker started and stopped working on an ingest, how many attempts each worker made, and what (if any) errors occurred. The summary also includes essential metadata about the item being ingested, including info from its tag files, the number of payload files in the bag, and the total size, in bytes, of the bag. These last bits of information may be particularly useful when diagnosing slow ingests. While a moderate-sized bag may typically ingest quickly, a moderate-sized bag containing tens of thousands of small files will take much longer to ingest. Deleting Redis Data Generally, there is no need to delete Redis data. There are only two cases where an APTrust admin would want to delete Redis data: When cancelling an ingest. You'll rarely do this. The system knows to cancel pending ingests when newer versions of the same bag arrive in a depositor's receiving bucket. When requeuing an ingest item all the way back to the pre-fetch stage. Deleting the Redis data will remove older error messages that might prevent ingest workers from processing the bag.","title":"Redis"},{"location":"redis/#redis","text":"Preservation Services workers use Redis to store interim processing data during ingest. Registry displays a summary of Redis data for WorkItems currently in progress. Only APTrust admins can see this data. The summary includes information about when each worker started and stopped working on an ingest, how many attempts each worker made, and what (if any) errors occurred. The summary also includes essential metadata about the item being ingested, including info from its tag files, the number of payload files in the bag, and the total size, in bytes, of the bag. These last bits of information may be particularly useful when diagnosing slow ingests. While a moderate-sized bag may typically ingest quickly, a moderate-sized bag containing tens of thousands of small files will take much longer to ingest.","title":"Redis"},{"location":"redis/#deleting-redis-data","text":"Generally, there is no need to delete Redis data. There are only two cases where an APTrust admin would want to delete Redis data: When cancelling an ingest. You'll rarely do this. The system knows to cancel pending ingests when newer versions of the same bag arrive in a depositor's receiving bucket. When requeuing an ingest item all the way back to the pre-fetch stage. Deleting the Redis data will remove older error messages that might prevent ingest workers from processing the bag.","title":"Deleting Redis Data"},{"location":"requests/","text":"Request Lifecycle Processing for virtually all Registry requests follows the same pattern, flowing through the these steps, in order: Authentication middleware ensures the user is logged in. Authorization middleware ensures the user is allowed to access the resources they are requesting. CSRF middlware ensures bad actors can't hijack valid user sessions to perform unsavory actions. The request handler mapped to the current URL is invoked. (URLs are mapped to handlers in app/application.go .) a. The request handler creates a web request or API request object to perform common basic operations. More on this below. b. The request handler performs its custom logic. c. The request handler constructs and returns a response. The Web Request Object The web request object performs the following common operations for virtually all requests: Populates common template data so the response template can display it. (E.g. the current user, the csrf token for HTML forms, a flash message, and more.) Determines whether the requested page should be displayed as a stand-alone page or a modal element. In the first case, the server will return a full HTML document with head and body elements. In the second it returns an HTML snippet, which is usually a single div. This code exists because in early iterations of the UI design, some elements changed from modal display to standalone pages and back again. Many pages still support both rendering methods. Clears out old flash cookies. If the request is for an index (list) page, the request object parses the filters from the query string, constructs the where clause for the query, loads results, and sets up a pager object that will let the user move through the result set. Note that each data model in the application's pgmodels directory includes a list of allowed filters. The web Request object parses the filter params and knows how to build a where clause from these. The where clause is SQL-safe, and the Request object will ignore any params that are not explicitly whitelisted. The API Request Object The API request object performs the same set of common tasks as the web request object, though it's tailored to assist in generating JSON output instead of HTML. Because the API allows creating and updating sensitive records, such as WorkItems, IntellectualObjects, and GenericFiles, the API request object's AssertValidIDs function does some additional sanity checking to prevent malformed and malicious API requests from touching records belonging to the wrong institutions. The ResourceAuthorization Model You'll notice that both the web and API request objects load the ResourceAuthorization model from the current request context. This model was constructed by the authorization middleware during its aurhorization check. This model contains some essential information for processing requests related to a single resource, including the resource type, ID, and identifier, as well as the ID of the institution that owns the resource. Request handlers use these IDs to load or update the requested resource.","title":"Requests"},{"location":"requests/#request-lifecycle","text":"Processing for virtually all Registry requests follows the same pattern, flowing through the these steps, in order: Authentication middleware ensures the user is logged in. Authorization middleware ensures the user is allowed to access the resources they are requesting. CSRF middlware ensures bad actors can't hijack valid user sessions to perform unsavory actions. The request handler mapped to the current URL is invoked. (URLs are mapped to handlers in app/application.go .) a. The request handler creates a web request or API request object to perform common basic operations. More on this below. b. The request handler performs its custom logic. c. The request handler constructs and returns a response.","title":"Request Lifecycle"},{"location":"requests/#the-web-request-object","text":"The web request object performs the following common operations for virtually all requests: Populates common template data so the response template can display it. (E.g. the current user, the csrf token for HTML forms, a flash message, and more.) Determines whether the requested page should be displayed as a stand-alone page or a modal element. In the first case, the server will return a full HTML document with head and body elements. In the second it returns an HTML snippet, which is usually a single div. This code exists because in early iterations of the UI design, some elements changed from modal display to standalone pages and back again. Many pages still support both rendering methods. Clears out old flash cookies. If the request is for an index (list) page, the request object parses the filters from the query string, constructs the where clause for the query, loads results, and sets up a pager object that will let the user move through the result set. Note that each data model in the application's pgmodels directory includes a list of allowed filters. The web Request object parses the filter params and knows how to build a where clause from these. The where clause is SQL-safe, and the Request object will ignore any params that are not explicitly whitelisted.","title":"The Web Request Object"},{"location":"requests/#the-api-request-object","text":"The API request object performs the same set of common tasks as the web request object, though it's tailored to assist in generating JSON output instead of HTML. Because the API allows creating and updating sensitive records, such as WorkItems, IntellectualObjects, and GenericFiles, the API request object's AssertValidIDs function does some additional sanity checking to prevent malformed and malicious API requests from touching records belonging to the wrong institutions.","title":"The API Request Object"},{"location":"requests/#the-resourceauthorization-model","text":"You'll notice that both the web and API request objects load the ResourceAuthorization model from the current request context. This model was constructed by the authorization middleware during its aurhorization check. This model contains some essential information for processing requests related to a single resource, including the resource type, ID, and identifier, as well as the ID of the institution that owns the resource. Request handlers use these IDs to load or update the requested resource.","title":"The ResourceAuthorization Model"},{"location":"requeuing/","text":"Requeuing WorkItems APTrust admins will see a button and a select list at the top of the WorkItem detail page for items that have not completed processing. There will be no requeue button for items that have finished ingest, restoration or deletion. We typically have to requeue items only after something went wrong. The most common reasons for requeing are temporary network and external service outages. The WorkItem note will contain information about what went wrong during processing, and the NeedsAdminReview flag will be set to true and the Retry flag will be set to false. In the requeue select list, Registry automatically pre-selects the stage where the item got stuck. Clicking the requeue button will clear the NeedsAdminReview flag, set Retry to true, change Status to Pending , and push the WorkItem ID back into the appropriate NSQ topic. You can requeue an ingest item back to an earlier stage of processing, though there is generally no need to do that, and doing so may cause the ingest workers to repeat already-completed work. Warning If you requeue an ingest item back to the pre-fetch stage, you should delete the item's Redis data so the ingest workers will ignore any previously recorded errors. Restoration and deletion items can also be requeued, though the need rarely arises.","title":"Requeing Work Items"},{"location":"requeuing/#requeuing-workitems","text":"APTrust admins will see a button and a select list at the top of the WorkItem detail page for items that have not completed processing. There will be no requeue button for items that have finished ingest, restoration or deletion. We typically have to requeue items only after something went wrong. The most common reasons for requeing are temporary network and external service outages. The WorkItem note will contain information about what went wrong during processing, and the NeedsAdminReview flag will be set to true and the Retry flag will be set to false. In the requeue select list, Registry automatically pre-selects the stage where the item got stuck. Clicking the requeue button will clear the NeedsAdminReview flag, set Retry to true, change Status to Pending , and push the WorkItem ID back into the appropriate NSQ topic. You can requeue an ingest item back to an earlier stage of processing, though there is generally no need to do that, and doing so may cause the ingest workers to repeat already-completed work. Warning If you requeue an ingest item back to the pre-fetch stage, you should delete the item's Redis data so the ingest workers will ignore any previously recorded errors. Restoration and deletion items can also be requeued, though the need rarely arises.","title":"Requeuing WorkItems"},{"location":"restoration/","text":"File and Object Restoration Users can request object restoration by clicking the Restore button on the object detail page. They can request file restoration by clicking the Restore on the file detail page, or under the expanded file detail view on an object detail page. For individual file restorations, the system will restore files from preservation storage to the depositor's restoration bucket. The file will be restored using its identifier as key. That is, file virginia.edu/photos/data/image1.jpg will be restored to aptrust.restore.virginia.edu/virginia.edu/photos/data/image1.jpg . Restored objects will be bagged and copied to the restoration bucket as a tar file. So, object virginia.edu/photos will be restored to aptrust.restore.virginia.edu/photos.tar . Because the files are being re-bagged, the they may appear in different order in the restored tar file than in the originally submitted tar file. Larger files and bags generally take longer to restore than smaller ones. Glacier Restorations Glacier Restorations work just like S3 and Wasabi restorations, except that items need to be moved from Glacier to S3 first, so they can be retrieved. That step can take up to five hours for items stored in regular Glacier archives, and up to twelve hours for items stored in Glacier Deep archives.","title":"Restoration"},{"location":"restoration/#file-and-object-restoration","text":"Users can request object restoration by clicking the Restore button on the object detail page. They can request file restoration by clicking the Restore on the file detail page, or under the expanded file detail view on an object detail page. For individual file restorations, the system will restore files from preservation storage to the depositor's restoration bucket. The file will be restored using its identifier as key. That is, file virginia.edu/photos/data/image1.jpg will be restored to aptrust.restore.virginia.edu/virginia.edu/photos/data/image1.jpg . Restored objects will be bagged and copied to the restoration bucket as a tar file. So, object virginia.edu/photos will be restored to aptrust.restore.virginia.edu/photos.tar . Because the files are being re-bagged, the they may appear in different order in the restored tar file than in the originally submitted tar file. Larger files and bags generally take longer to restore than smaller ones.","title":"File and Object Restoration"},{"location":"restoration/#glacier-restorations","text":"Glacier Restorations work just like S3 and Wasabi restorations, except that items need to be moved from Glacier to S3 first, so they can be retrieved. That step can take up to five hours for items stored in regular Glacier archives, and up to twelve hours for items stored in Glacier Deep archives.","title":"Glacier Restorations"},{"location":"settings/","text":"Settings Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD Setting Definitions Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Settings"},{"location":"settings/#settings","text":"Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD","title":"Settings"},{"location":"settings/#setting-definitions","text":"Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Setting Definitions"},{"location":"structure/","text":"Code Structure The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"structure/#code-structure","text":"The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"testing/","text":"Testing To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up. Thorough Testing Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Testing"},{"location":"testing/#testing","text":"To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up.","title":"Testing"},{"location":"testing/#thorough-testing","text":"Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Thorough Testing"},{"location":"ui-components/","text":"UI Components The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"ui-components/#ui-components","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"user-management/","text":"User Management Institutional admins can add, edit, and delete user accounts at their own institutions. APTrust admins can add, edit, and delete user accounts belonging to any institution. Institutional users can edit only their own account. Note that user deletion is \"soft deletion,\" in which the system simply marks the user's account inactive. Inactives cannot log in until an admin reactivates their account. The system does not delete users because their account records must remain in order for audit records to make sense. WorkItems, for example, record info about who requested file and object restorations. Deletion records include info about who requested and who approved a deletion. Admins can manage users by clicking the User link in the left nav bar. From there, the process should be intuitive. Note that after adding a new user, you will need to request AWS keys from APTrust for that user; otherwise, they won't be able to access S3 buckets for ingest and restoration.","title":"User Management"},{"location":"user-management/#user-management","text":"Institutional admins can add, edit, and delete user accounts at their own institutions. APTrust admins can add, edit, and delete user accounts belonging to any institution. Institutional users can edit only their own account. Note that user deletion is \"soft deletion,\" in which the system simply marks the user's account inactive. Inactives cannot log in until an admin reactivates their account. The system does not delete users because their account records must remain in order for audit records to make sense. WorkItems, for example, record info about who requested file and object restorations. Deletion records include info about who requested and who approved a deletion. Admins can manage users by clicking the User link in the left nav bar. From there, the process should be intuitive. Note that after adding a new user, you will need to request AWS keys from APTrust for that user; otherwise, they won't be able to access S3 buckets for ingest and restoration.","title":"User Management"},{"location":"security/","text":"Security Overview Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rails devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler. About Middleware The Gin web framework allows us to define middleware that executes before (and after) a request reaches our application's request handlers. The initMiddleware() function in application.go defines four middlewares to be executed in order. The first is a general logger. It always passes control to the next middlware, which is Authentication . If the authentication middleware determines the current user can proceed with the request, it passes control to the next middleware, which is authorization. If the authenticated middleware determines the user cannot proceed with the request (because the request requires authentication and the user is missing a valid session cookie), it sends an error response and the request ends there. It never even reaches the authorization step. The Authorization middleware checks to see if the user is authorized to perform the requested action or to access the requested resource. If so, it passes the request on to the CSRF middleware. If not, request processing ends here, with the middleware returning an error response to the user. If the user is attempting a PUT or POST request, the CSRF middleware ensures that the request includes valid CSRF tokens. If a token is missing from the cookie or the form, or if the tokens don't match, processing end here with the CSRF middleware returning an error response. Middlewares push requests to the next step of processing by calling the Next() function. Note that middlewares can touch the response object in the Gin context after calling Next() , though Registry does not do this. Maintainers can add post-processing in future generations of Registry if necessary.","title":"Security Overview"},{"location":"security/#security-overview","text":"Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rails devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler.","title":"Security Overview"},{"location":"security/#about-middleware","text":"The Gin web framework allows us to define middleware that executes before (and after) a request reaches our application's request handlers. The initMiddleware() function in application.go defines four middlewares to be executed in order. The first is a general logger. It always passes control to the next middlware, which is Authentication . If the authentication middleware determines the current user can proceed with the request, it passes control to the next middleware, which is authorization. If the authenticated middleware determines the user cannot proceed with the request (because the request requires authentication and the user is missing a valid session cookie), it sends an error response and the request ends there. It never even reaches the authorization step. The Authorization middleware checks to see if the user is authorized to perform the requested action or to access the requested resource. If so, it passes the request on to the CSRF middleware. If not, request processing ends here, with the middleware returning an error response to the user. If the user is attempting a PUT or POST request, the CSRF middleware ensures that the request includes valid CSRF tokens. If a token is missing from the cookie or the form, or if the tokens don't match, processing end here with the CSRF middleware returning an error response. Middlewares push requests to the next step of processing by calling the Next() function. Note that middlewares can touch the response object in the Gin context after calling Next() , though Registry does not do this. Maintainers can add post-processing in future generations of Registry if necessary.","title":"About Middleware"},{"location":"security/authentication/","text":"Authentication Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API. Web UI While the UserSignInShow() and UserSignIn() methods of the Users Controller handle the sign-in process, the Authentication middleware checks the session cookie on subsequent requests. The session cookie contains an encrypted User ID, which the authentication middleware uses to look up the user record. It then stores the User object in the Gin context for later access. The authentication middleware ensures the following: That the request includes a valid user session cookie with a valid user if the request tries to access a protected resource. See below for a list of resources that do not require authentication. That the user will be forced to complete the password change process before accessing any other resources, if the user happens to be in the middle of the password change process. That the user will be forced to complete the second step of two-factor authentication before accessing any other resources, if they have logged in with their email and password and have not yet completed the second step of two-factor auth. Endpoints Exempt from Authorization The middleware/authentication.go includes a function called ExemptFromAuth() to check whether the current request is exempt from authentication. Currently, the following endpoints are exempt: Endpoint Explanation /users/sign_in Users obviously won't be logged in when they go to the sign-in page. They have to be able to see it to log in. /users/sign_out This page tells the user they've signed out. /users/forgot_password This page is for users who have forgotten their password and received a password-reset email. The page includes a text input for them to enter the password reset token we sent them. /users/complete_password_reset/ After entering their reset token, users choose a new password on this page. The app includes security measures to prevent people accessing this page without having previously entered the reset token. /ui-components This page displays a gallery of UI components, for developer reference. It's static and contains no sensitive information. /static/* This is the prefix for all static resources, including scripts, stylesheets, icons and fonts. /favicon/* This returns the site's favicon. /error This page displayes errors, including errors telling you you need to log in. API If the Authentication middleware detects that the user has requested an API endpoint rather than a web endpoint, the GetUserFromAPIHeaders() function extracts the header values for X-Pharos-API-User and X-Pharos-API-Key and loads the user based on their API key.","title":"Authentication"},{"location":"security/authentication/#authentication","text":"Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API.","title":"Authentication"},{"location":"security/authentication/#web-ui","text":"While the UserSignInShow() and UserSignIn() methods of the Users Controller handle the sign-in process, the Authentication middleware checks the session cookie on subsequent requests. The session cookie contains an encrypted User ID, which the authentication middleware uses to look up the user record. It then stores the User object in the Gin context for later access. The authentication middleware ensures the following: That the request includes a valid user session cookie with a valid user if the request tries to access a protected resource. See below for a list of resources that do not require authentication. That the user will be forced to complete the password change process before accessing any other resources, if the user happens to be in the middle of the password change process. That the user will be forced to complete the second step of two-factor authentication before accessing any other resources, if they have logged in with their email and password and have not yet completed the second step of two-factor auth.","title":"Web UI"},{"location":"security/authentication/#endpoints-exempt-from-authorization","text":"The middleware/authentication.go includes a function called ExemptFromAuth() to check whether the current request is exempt from authentication. Currently, the following endpoints are exempt: Endpoint Explanation /users/sign_in Users obviously won't be logged in when they go to the sign-in page. They have to be able to see it to log in. /users/sign_out This page tells the user they've signed out. /users/forgot_password This page is for users who have forgotten their password and received a password-reset email. The page includes a text input for them to enter the password reset token we sent them. /users/complete_password_reset/ After entering their reset token, users choose a new password on this page. The app includes security measures to prevent people accessing this page without having previously entered the reset token. /ui-components This page displays a gallery of UI components, for developer reference. It's static and contains no sensitive information. /static/* This is the prefix for all static resources, including scripts, stylesheets, icons and fonts. /favicon/* This returns the site's favicon. /error This page displayes errors, including errors telling you you need to log in.","title":"Endpoints Exempt from Authorization"},{"location":"security/authentication/#api","text":"If the Authentication middleware detects that the user has requested an API endpoint rather than a web endpoint, the GetUserFromAPIHeaders() function extracts the header values for X-Pharos-API-User and X-Pharos-API-Key and loads the user based on their API key.","title":"API"},{"location":"security/authorization/","text":"Authorization Authorization middleware runs after authentication middleware. By the time it touches the request, the authentication middlware has added the User object to the current request. The authorization middlware uses that User object to do the following: Check the URL/request path to see what type of resource the user is requesting. If the resource maps to a specific database record (a work item, generic file, intellectual object, etc.), it looks up the record to see which institution it belongs to. Check the authrorization map to see if the user is allowed to access that particular resource belonging to that particular institution. Constructs a ResourceAuthorization object with the following information: Handler - The name of the HTTP handler function that will handle the user's request. ResourceID - The unique id of the resource (work item, file, obect, etc.) the user requested. This will be zero if the user is requesting a list of items. ResourceIdentifier - The string identifier of the requested resource. This applies to institutions, intellectual objects and generic files. ResourceInstId - The ID of the institution to which the resource belongs. ResourceType - The type of resource (IntellectualObject, WorkItem, GenericFile, etc.). Permission - The permission required to access the requested resource. These are defined in constants/permissions . Checked - True or false, indicating whether the authorization middleware checked that the user has permission to access the requested resource. Approved - True or false, indicating whether the user has permission to access the requested resource. Error - Describes any error that occurred during the authorization check. The authorization middleware will not let a request proceed unless the ResourceAuthorization object's Checked and Approved attrbutes are both true. Things to Note If, when adding a new endpoint, you to forget to define a permission for it, you will never be able to reach that endpoint, because without a defined permission, ResourceAuthorization.Checked will be false. Requests for list endpoints, such as the WorkItems list and the IntellectualObject list, cannot include a ResourceID or a ResourceInstID, because the requests don't target a single resource. Unless the requesting user is an APTrust admin, database queries issued by these requests will always include an Institution ID filter, with the ID set to the user's own institution ID. For example, when a user from virginia.edu requests a list of WorkItems, objects, or files, the system will force a where clause into their queries stating where institution_id = [user's institution id] . This occurs in the LoadResourceList() function of the Web UI's Request object and in the LoadResourceList() function of the API's Request object . The authorization middleware issues a lightweight query to return the model's insitution id. We want these queries to be as light as possible, since they run on every request. You'll find these queries in the InstIDFor() function in pgmodel.go . The ResourceAuthorization Model The ResourceAuthorization model constructed by the authorization middleware will be used later by the request handlers. For more on that, see the Requests page. Permission Definitions All of Registry's permission are defined in constants/permissions.go . The initPermissions() function in that file assigns permissions to roles like so: // Institutional User Role instUser [ ChecksumRead ] = true instUser [ DashboardShow ] = true // ... additional permissions omitted for brevity... // Institutional Admin Role instAdmin [ FileDelete ] = true instAdmin [ FileRead ] = true // ... additional permissions omitted for brevity... // Sys Admin Role sysAdmin [ ChecksumCreate ] = true sysAdmin [ ChecksumDelete ] = false // no one can do this sysAdmin [ ChecksumRead ] = true // ... additional permissions omitted for brevity... Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. Important No role has any permission unless it is explicitly granted in constants/permissions.go , and some permissions are explicitly denied to all users because they violate business rules. For example, no user can delete checksums or delete or alter PREMIS events. The endpoints to perform these actions don't even exist, and the underlying data models will throw errors if anyone even tries to perform these actions. Permission Mapping While permissions are defined and assigned to roles in constants/permissions.go , they are mapped to request handlers in middleware/authorization_map.go . The authorization map tells the app which permission is required to access each request handler. Important If you don't map a permission to your new request handler, no one will be able to reach it, ever, because the authorization check will fail. Permission Checking The middleware/authorization.go middleware figures out which request handler responds to the current URL. It reads the authorization map to see which permission is required to access that handler, then determines whether the current user is allowed to call that handler. It also does further checks, as described above, to see if the user can access whatever resources that handler touches. List of Authorization-Related Files File Description constants/permissions.go Defines all of the system permissions and assigns them to roles at application start. middleware/authorization_map.go Maps permissions to web and API request handlers. middleware/authorize.go Authorizes requests and decides whether or not to pass the request on to the handler. middleware/resource_authorization.go Includes logic to compare user permissions to the authorization map, and to do fine-grained resource-level checks. (I.e. Ensures objects user is requesting actually belong to that user's institution.) web/webui/request.go Enforces filters in list requests to ensure users access only resources belonging to their own institution. web/api/request/go Enforces filters in API list requests to ensure users access only resources belonging to their own institution.","title":"Authorization"},{"location":"security/authorization/#authorization","text":"Authorization middleware runs after authentication middleware. By the time it touches the request, the authentication middlware has added the User object to the current request. The authorization middlware uses that User object to do the following: Check the URL/request path to see what type of resource the user is requesting. If the resource maps to a specific database record (a work item, generic file, intellectual object, etc.), it looks up the record to see which institution it belongs to. Check the authrorization map to see if the user is allowed to access that particular resource belonging to that particular institution. Constructs a ResourceAuthorization object with the following information: Handler - The name of the HTTP handler function that will handle the user's request. ResourceID - The unique id of the resource (work item, file, obect, etc.) the user requested. This will be zero if the user is requesting a list of items. ResourceIdentifier - The string identifier of the requested resource. This applies to institutions, intellectual objects and generic files. ResourceInstId - The ID of the institution to which the resource belongs. ResourceType - The type of resource (IntellectualObject, WorkItem, GenericFile, etc.). Permission - The permission required to access the requested resource. These are defined in constants/permissions . Checked - True or false, indicating whether the authorization middleware checked that the user has permission to access the requested resource. Approved - True or false, indicating whether the user has permission to access the requested resource. Error - Describes any error that occurred during the authorization check. The authorization middleware will not let a request proceed unless the ResourceAuthorization object's Checked and Approved attrbutes are both true.","title":"Authorization"},{"location":"security/authorization/#things-to-note","text":"If, when adding a new endpoint, you to forget to define a permission for it, you will never be able to reach that endpoint, because without a defined permission, ResourceAuthorization.Checked will be false. Requests for list endpoints, such as the WorkItems list and the IntellectualObject list, cannot include a ResourceID or a ResourceInstID, because the requests don't target a single resource. Unless the requesting user is an APTrust admin, database queries issued by these requests will always include an Institution ID filter, with the ID set to the user's own institution ID. For example, when a user from virginia.edu requests a list of WorkItems, objects, or files, the system will force a where clause into their queries stating where institution_id = [user's institution id] . This occurs in the LoadResourceList() function of the Web UI's Request object and in the LoadResourceList() function of the API's Request object . The authorization middleware issues a lightweight query to return the model's insitution id. We want these queries to be as light as possible, since they run on every request. You'll find these queries in the InstIDFor() function in pgmodel.go .","title":"Things to Note"},{"location":"security/authorization/#the-resourceauthorization-model","text":"The ResourceAuthorization model constructed by the authorization middleware will be used later by the request handlers. For more on that, see the Requests page.","title":"The ResourceAuthorization Model"},{"location":"security/authorization/#permission-definitions","text":"All of Registry's permission are defined in constants/permissions.go . The initPermissions() function in that file assigns permissions to roles like so: // Institutional User Role instUser [ ChecksumRead ] = true instUser [ DashboardShow ] = true // ... additional permissions omitted for brevity... // Institutional Admin Role instAdmin [ FileDelete ] = true instAdmin [ FileRead ] = true // ... additional permissions omitted for brevity... // Sys Admin Role sysAdmin [ ChecksumCreate ] = true sysAdmin [ ChecksumDelete ] = false // no one can do this sysAdmin [ ChecksumRead ] = true // ... additional permissions omitted for brevity... Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. Important No role has any permission unless it is explicitly granted in constants/permissions.go , and some permissions are explicitly denied to all users because they violate business rules. For example, no user can delete checksums or delete or alter PREMIS events. The endpoints to perform these actions don't even exist, and the underlying data models will throw errors if anyone even tries to perform these actions.","title":"Permission Definitions"},{"location":"security/authorization/#permission-mapping","text":"While permissions are defined and assigned to roles in constants/permissions.go , they are mapped to request handlers in middleware/authorization_map.go . The authorization map tells the app which permission is required to access each request handler. Important If you don't map a permission to your new request handler, no one will be able to reach it, ever, because the authorization check will fail.","title":"Permission Mapping"},{"location":"security/authorization/#permission-checking","text":"The middleware/authorization.go middleware figures out which request handler responds to the current URL. It reads the authorization map to see which permission is required to access that handler, then determines whether the current user is allowed to call that handler. It also does further checks, as described above, to see if the user can access whatever resources that handler touches.","title":"Permission Checking"},{"location":"security/authorization/#list-of-authorization-related-files","text":"File Description constants/permissions.go Defines all of the system permissions and assigns them to roles at application start. middleware/authorization_map.go Maps permissions to web and API request handlers. middleware/authorize.go Authorizes requests and decides whether or not to pass the request on to the handler. middleware/resource_authorization.go Includes logic to compare user permissions to the authorization map, and to do fine-grained resource-level checks. (I.e. Ensures objects user is requesting actually belong to that user's institution.) web/webui/request.go Enforces filters in list requests to ensure users access only resources belonging to their own institution. web/api/request/go Enforces filters in API list requests to ensure users access only resources belonging to their own institution.","title":"List of Authorization-Related Files"},{"location":"security/csrf/","text":"Cross-Site Request Forgery The CSRF middleware is the last to run. It does the following: Checks to see whether the request method is unsafe. Any method other than GET, HEAD, OPTIONS and TRACE is considered unsafe because it could add, delete, or alter data. If the method is unsafe, it checks to ensure that the request includes matching CSRF tokens in the cookie headers and in the submitted form. If either token is missing, or if the tokens don't match, the server stops processing the request and returns an error. This middleware will also reject unsafe requests coming from other domains. For a concise description on how CSRF attacks work and how anti-forgery tokens can prevent them, see Microsoft's CSRF write-up .","title":"Cross-Site Request Forgery"},{"location":"security/csrf/#cross-site-request-forgery","text":"The CSRF middleware is the last to run. It does the following: Checks to see whether the request method is unsafe. Any method other than GET, HEAD, OPTIONS and TRACE is considered unsafe because it could add, delete, or alter data. If the method is unsafe, it checks to ensure that the request includes matching CSRF tokens in the cookie headers and in the submitted form. If either token is missing, or if the tokens don't match, the server stops processing the request and returns an error. This middleware will also reject unsafe requests coming from other domains. For a concise description on how CSRF attacks work and how anti-forgery tokens can prevent them, see Microsoft's CSRF write-up .","title":"Cross-Site Request Forgery"},{"location":"security/headers/","text":"Default Headers The Authentication middleware, which is the first to touch each request, also sets some default headers. We want to set these headers as soon as possible in the response lifecycle because we want to those headers to be present even when authenticaion fails and the auth middleware responds directly to the user. Most of these headers are security-related, so we document them here. The Authentication middleware's SetDefaultHeaders() function sets the following: Name Value Description Cache-Control no-cache Tells browsers and proxies not to cache responses. This is set only for dynamic content, not for static content like scripts, stylesheets and images. Pragma no-store Same as Cache-Control above, but for really old browsers. Strict-Transport-Security max-age=31536000 Forces clients to use HTTPS instead of HTTP. X-XSS-Protection 1 Instructs browsers to stop loading or sanitize the page if they detect a cross-site scripting attack. X-Content-Type-Options \"nosniff\" Blocks content sniffing that could transform non-executable MIME types into executable MIME types. Content-Security-Policy \"default-src 'self'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com; script-src 'self' 'unsafe-inline'\" Prevents some cross-site scripting and data injection attacks. The policy spelled out in the value of this header says the browser should trust scripts, fonts, and stylesheets from our own domain. It should also accept fonts from Google's font serving domain, fonts.gstatic.com and CSS from fonts.googlapis.com. The unsafe-inline statements mean the browser should trust inline JavaScript from our domain and inline CSS from fonts.googleapis.com. Confirming browsers will reject fonts, scripts, and stylesheets from other sources.","title":"Default Headers"},{"location":"security/headers/#default-headers","text":"The Authentication middleware, which is the first to touch each request, also sets some default headers. We want to set these headers as soon as possible in the response lifecycle because we want to those headers to be present even when authenticaion fails and the auth middleware responds directly to the user. Most of these headers are security-related, so we document them here. The Authentication middleware's SetDefaultHeaders() function sets the following: Name Value Description Cache-Control no-cache Tells browsers and proxies not to cache responses. This is set only for dynamic content, not for static content like scripts, stylesheets and images. Pragma no-store Same as Cache-Control above, but for really old browsers. Strict-Transport-Security max-age=31536000 Forces clients to use HTTPS instead of HTTP. X-XSS-Protection 1 Instructs browsers to stop loading or sanitize the page if they detect a cross-site scripting attack. X-Content-Type-Options \"nosniff\" Blocks content sniffing that could transform non-executable MIME types into executable MIME types. Content-Security-Policy \"default-src 'self'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com; script-src 'self' 'unsafe-inline'\" Prevents some cross-site scripting and data injection attacks. The policy spelled out in the value of this header says the browser should trust scripts, fonts, and stylesheets from our own domain. It should also accept fonts from Google's font serving domain, fonts.gstatic.com and CSS from fonts.googlapis.com. The unsafe-inline statements mean the browser should trust inline JavaScript from our domain and inline CSS from fonts.googleapis.com. Confirming browsers will reject fonts, scripts, and stylesheets from other sources.","title":"Default Headers"},{"location":"security/roles/","text":"Roles and Privileges Registry uses role-based privileges. Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. The table below describes who can do what. Feature Web UI Member API Admin API Roles Allowed Ownership Restrictions Description and Notes Alert \u2013 List \u2713 All User\u2019s own alerts View alerts pertaining to your account. Alert \u2013 Mark Read \u2713 All User\u2019s own alerts Mark alerts as read. Alert \u2013 Mark Unread \u2713 All User\u2019s own alerts Mark alerts as unread. Alert \u2013 Show \u2713 All User\u2019s own alerts Show the text of an alert. Checksum \u2013 Create \u2713 System account None Create a new checksum for a Generic File. Checksum \u2013 List \u2713 \u2713 All User\u2019s own institution List checksums for Generic Files. Checksum \u2013 Show \u2713 \u2713 All User\u2019s own institution Show details of a checksum. Dashboard \u2013 Show \u2713 All User\u2019s own institution Show the dashboard, with an overview of deposits and recent work items. Deletion \u2013 Approve \u2713 Inst. Admin only User\u2019s own institution Approve a file or object deletion request submitted by another user at your institution. Deletion \u2013 List \u2713 Inst. Admin only User\u2019s own institution Display a list of deletion requests for your institution. Deletion \u2013 Reject \u2713 Inst. Admin only User\u2019s own institution Reject a file/object deletion request. Deletion \u2013 Review \u2713 Inst. Admin only User\u2019s own institution Review a file/object deletion request with the option to approve or reject it. Deletion \u2013 Show \u2713 \u2713 All User\u2019s own institution Display a file/object deletion request without the object to approve or reject it. Generic File \u2013 Create \u2713 System account Create a single Generic Files. This happens only when recording a successful ingest. Generic File \u2013 Create Batch \u2713 System account Create a batch of Generic Files. This happens only when recording a successful ingest. Generic File \u2013 Delete \u2713 Inst. Admin only User\u2019s own institution Delete a Generic File. This happens only after deletion request has been approved. Generic File \u2013 Edit \u2713 System account Edit a Generic File. This happens only when re-ingesting an existing file. Generic File \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Generic Files belonging to your institution. Generic File \u2013 Request Delete \u2713 Inst. Admin only User\u2019s own institution Request deletion of one of your institution\u2019s files. (Deletion must be approved by an institutional admin.) Generic File \u2013 Request Restore \u2713 All User\u2019s own institution Request restoration of one of your institution\u2019s files. Generic File \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Display details of a Generic File belonging to your institution. Institution \u2013 Create \u2713 APTrust admin Create a new institution. Institution \u2013 Delete \u2713 APTrust admin Soft-deletes an institution by marking it as inactive. Institution \u2013 Edit \u2713 APTrust admin Edit an existing institution. Institution \u2013 List \u2713 \u2713 APTrust admin, System account List all institutions. Institution \u2013 Show \u2713 \u2713 APTrust admin, System account Show details of an institution. Institution \u2013 Undelete \u2713 APTrust admin, System account Reactivate a \u201cdeleted\u201d institution. Intellectual Object \u2013 Create \u2713 System account Create an Intellectual Object. This happens only when recording a successful ingest. Intellectual Object \u2013 Delete \u2713 System account Only after approval by institutional admin Intellectual Object \u2013 Edit \u2713 System account Edit an Intellectual Object. This happens only when re-ingesting an existing object. Intellectual Object \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Intellectual Objects belonging to your institution. Intellectual Object \u2013 List Events \u2713 All User\u2019s own institution List Premis events associated with an Intellectual Object. Intellectual Object \u2013 List Files \u2713 All User\u2019s own institution List Generic Files associated with an Intellectual Object. Intellectual Object \u2013 Request Delete \u2713 Inst. Admin only Request deletion of an Intellectual Object. (Deletion must approved by an institutional admin.) Intellectual Object \u2013 Request Restore \u2713 All User\u2019s own institution Request restoration of one of your institution\u2019s Intellectual Objects. Intellectual Object \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show details of an Intellectual Object. NSQ \u2013 Admin \u2713 APTrust admin Show NSQ admin panel. Premis Event \u2013 Create \u2713 System account Create a Premis event. This happens on ingest, fixity check, deletion. Premis Event \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Premis events belonging to your institution. Premis Event \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show details of a Premis event. Storage Record \u2013 Create \u2713 System account Create a storage record describing where a file is stored. This happens only when recording a successful ingest. Storage Record \u2013 List \u2713 System account Show a list of storage records. Non-system users can see Storage Records as part of file detail in web UI. Storage Record \u2013 Show \u2713 System account Display details of a storage record. Non-admin users can see Storage Records as part of file detail in web UI. User \u2013 Confirm Phone \u2713 All User\u2019s own account Confirm your phone number for two-factor authentication by entering the code we sent you. User \u2013 Create \u2713 Inst. Admin, APTrust admin User\u2019s own institution Create a new user. User \u2013 Delete \u2713 Inst. Admin, APTrust admin User\u2019s own institution Soft-deletes a user by marking them as inactive. User \u2013 Edit \u2713 Inst. Admin, APTrust admin User\u2019s own institution Users can edit their own details, but not others, unless they\u2019re an admin. User \u2013 Forgot Password \u2713 All User\u2019s own account Sends an email to you with a link to help you log in. User \u2013 Generate API Key \u2713 All User\u2019s own account Generates an API key so you can access the member API. User \u2013 Generate Backup Codes \u2713 All User\u2019s own account Generates backup codes that two-factor auth users can use to login when they don\u2019t have access to their phone. User \u2013 List \u2713 Inst. Admin, APTrust admin User\u2019s own institution Displays a list of users at your institution. User \u2013 Login Second Factor \u2713 All User\u2019s own account Allows users to enter backup or SMS codes for second factor of login. User \u2013 My Account \u2713 All User\u2019s own account Display the details of your account. User \u2013 Reset Password \u2713 All User\u2019s own account Reset your password. User \u2013 Set Up 2-Factor Auth \u2713 All User\u2019s own account Begin the two-factor authentication setup process by choosing Authy or SMS. User \u2013 Show \u2713 Inst. Admin, APTrust admin User\u2019s own institution Display the details of another user\u2019s account. User \u2013 Sign In \u2713 All User\u2019s own account Sign in to the web UI. User \u2013 Sign Out \u2713 All User\u2019s own account Sign out of the web UI. User \u2013 Undelete \u2713 Inst. Admin, APTrust admin User\u2019s own institution Reactivate a \u201cdeleted\u201d user. WorkItem \u2013 Create \u2713 System account Create a new WorkItem. WorkItem \u2013 Delete Redis Data \u2713 APTrust admin Delete the Redis data associated with a WorkItem. Do this only when requeuing an item back to the first stage of ingest, and only when you really want to throw out all the metadata and start over. WorkItem \u2013 Edit \u2713 \u2713 APTrust admin, System account Edit an existing work item. WorkItem \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List work items for your institution. WorkItem \u2013 Requeue \u2713 APTrust admin Requeue a work item so workers will retry it. WorkItem \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show the details of an individual work item.","title":"Roles and Privileges"},{"location":"security/roles/#roles-and-privileges","text":"Registry uses role-based privileges. Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. The table below describes who can do what. Feature Web UI Member API Admin API Roles Allowed Ownership Restrictions Description and Notes Alert \u2013 List \u2713 All User\u2019s own alerts View alerts pertaining to your account. Alert \u2013 Mark Read \u2713 All User\u2019s own alerts Mark alerts as read. Alert \u2013 Mark Unread \u2713 All User\u2019s own alerts Mark alerts as unread. Alert \u2013 Show \u2713 All User\u2019s own alerts Show the text of an alert. Checksum \u2013 Create \u2713 System account None Create a new checksum for a Generic File. Checksum \u2013 List \u2713 \u2713 All User\u2019s own institution List checksums for Generic Files. Checksum \u2013 Show \u2713 \u2713 All User\u2019s own institution Show details of a checksum. Dashboard \u2013 Show \u2713 All User\u2019s own institution Show the dashboard, with an overview of deposits and recent work items. Deletion \u2013 Approve \u2713 Inst. Admin only User\u2019s own institution Approve a file or object deletion request submitted by another user at your institution. Deletion \u2013 List \u2713 Inst. Admin only User\u2019s own institution Display a list of deletion requests for your institution. Deletion \u2013 Reject \u2713 Inst. Admin only User\u2019s own institution Reject a file/object deletion request. Deletion \u2013 Review \u2713 Inst. Admin only User\u2019s own institution Review a file/object deletion request with the option to approve or reject it. Deletion \u2013 Show \u2713 \u2713 All User\u2019s own institution Display a file/object deletion request without the object to approve or reject it. Generic File \u2013 Create \u2713 System account Create a single Generic Files. This happens only when recording a successful ingest. Generic File \u2013 Create Batch \u2713 System account Create a batch of Generic Files. This happens only when recording a successful ingest. Generic File \u2013 Delete \u2713 Inst. Admin only User\u2019s own institution Delete a Generic File. This happens only after deletion request has been approved. Generic File \u2013 Edit \u2713 System account Edit a Generic File. This happens only when re-ingesting an existing file. Generic File \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Generic Files belonging to your institution. Generic File \u2013 Request Delete \u2713 Inst. Admin only User\u2019s own institution Request deletion of one of your institution\u2019s files. (Deletion must be approved by an institutional admin.) Generic File \u2013 Request Restore \u2713 All User\u2019s own institution Request restoration of one of your institution\u2019s files. Generic File \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Display details of a Generic File belonging to your institution. Institution \u2013 Create \u2713 APTrust admin Create a new institution. Institution \u2013 Delete \u2713 APTrust admin Soft-deletes an institution by marking it as inactive. Institution \u2013 Edit \u2713 APTrust admin Edit an existing institution. Institution \u2013 List \u2713 \u2713 APTrust admin, System account List all institutions. Institution \u2013 Show \u2713 \u2713 APTrust admin, System account Show details of an institution. Institution \u2013 Undelete \u2713 APTrust admin, System account Reactivate a \u201cdeleted\u201d institution. Intellectual Object \u2013 Create \u2713 System account Create an Intellectual Object. This happens only when recording a successful ingest. Intellectual Object \u2013 Delete \u2713 System account Only after approval by institutional admin Intellectual Object \u2013 Edit \u2713 System account Edit an Intellectual Object. This happens only when re-ingesting an existing object. Intellectual Object \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Intellectual Objects belonging to your institution. Intellectual Object \u2013 List Events \u2713 All User\u2019s own institution List Premis events associated with an Intellectual Object. Intellectual Object \u2013 List Files \u2713 All User\u2019s own institution List Generic Files associated with an Intellectual Object. Intellectual Object \u2013 Request Delete \u2713 Inst. Admin only Request deletion of an Intellectual Object. (Deletion must approved by an institutional admin.) Intellectual Object \u2013 Request Restore \u2713 All User\u2019s own institution Request restoration of one of your institution\u2019s Intellectual Objects. Intellectual Object \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show details of an Intellectual Object. NSQ \u2013 Admin \u2713 APTrust admin Show NSQ admin panel. Premis Event \u2013 Create \u2713 System account Create a Premis event. This happens on ingest, fixity check, deletion. Premis Event \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List Premis events belonging to your institution. Premis Event \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show details of a Premis event. Storage Record \u2013 Create \u2713 System account Create a storage record describing where a file is stored. This happens only when recording a successful ingest. Storage Record \u2013 List \u2713 System account Show a list of storage records. Non-system users can see Storage Records as part of file detail in web UI. Storage Record \u2013 Show \u2713 System account Display details of a storage record. Non-admin users can see Storage Records as part of file detail in web UI. User \u2013 Confirm Phone \u2713 All User\u2019s own account Confirm your phone number for two-factor authentication by entering the code we sent you. User \u2013 Create \u2713 Inst. Admin, APTrust admin User\u2019s own institution Create a new user. User \u2013 Delete \u2713 Inst. Admin, APTrust admin User\u2019s own institution Soft-deletes a user by marking them as inactive. User \u2013 Edit \u2713 Inst. Admin, APTrust admin User\u2019s own institution Users can edit their own details, but not others, unless they\u2019re an admin. User \u2013 Forgot Password \u2713 All User\u2019s own account Sends an email to you with a link to help you log in. User \u2013 Generate API Key \u2713 All User\u2019s own account Generates an API key so you can access the member API. User \u2013 Generate Backup Codes \u2713 All User\u2019s own account Generates backup codes that two-factor auth users can use to login when they don\u2019t have access to their phone. User \u2013 List \u2713 Inst. Admin, APTrust admin User\u2019s own institution Displays a list of users at your institution. User \u2013 Login Second Factor \u2713 All User\u2019s own account Allows users to enter backup or SMS codes for second factor of login. User \u2013 My Account \u2713 All User\u2019s own account Display the details of your account. User \u2013 Reset Password \u2713 All User\u2019s own account Reset your password. User \u2013 Set Up 2-Factor Auth \u2713 All User\u2019s own account Begin the two-factor authentication setup process by choosing Authy or SMS. User \u2013 Show \u2713 Inst. Admin, APTrust admin User\u2019s own institution Display the details of another user\u2019s account. User \u2013 Sign In \u2713 All User\u2019s own account Sign in to the web UI. User \u2013 Sign Out \u2713 All User\u2019s own account Sign out of the web UI. User \u2013 Undelete \u2713 Inst. Admin, APTrust admin User\u2019s own institution Reactivate a \u201cdeleted\u201d user. WorkItem \u2013 Create \u2713 System account Create a new WorkItem. WorkItem \u2013 Delete Redis Data \u2713 APTrust admin Delete the Redis data associated with a WorkItem. Do this only when requeuing an item back to the first stage of ingest, and only when you really want to throw out all the metadata and start over. WorkItem \u2013 Edit \u2713 \u2713 APTrust admin, System account Edit an existing work item. WorkItem \u2013 List \u2713 \u2713 \u2713 All User\u2019s own institution List work items for your institution. WorkItem \u2013 Requeue \u2713 APTrust admin Requeue a work item so workers will retry it. WorkItem \u2013 Show \u2713 \u2713 \u2713 All User\u2019s own institution Show the details of an individual work item.","title":"Roles and Privileges"}]}