{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The APTrust Registry The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests. External Components & Services The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"Home"},{"location":"#the-aptrust-registry","text":"The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests.","title":"The APTrust Registry"},{"location":"#external-components-services","text":"The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"External Components &amp; Services"},{"location":"components/","text":"Code Components The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages. The Application File The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries. Template Helpers The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go Constants constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied. The Configuration Object The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below. The Context Object The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message. Security Middleware Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle. The Request Object The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.) The Pager The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it. Custom Forms The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form . Views Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup. Models The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM. Web and API Handlers All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file . UI Components Page The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"Key Code Components"},{"location":"components/#code-components","text":"The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages.","title":"Code Components"},{"location":"components/#the-application-file","text":"The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries.","title":"The Application File"},{"location":"components/#template-helpers","text":"The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go","title":"Template Helpers"},{"location":"components/#constants","text":"constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied.","title":"Constants"},{"location":"components/#the-configuration-object","text":"The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below.","title":"The Configuration Object"},{"location":"components/#the-context-object","text":"The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message.","title":"The Context Object"},{"location":"components/#security-middleware","text":"Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle.","title":"Security Middleware"},{"location":"components/#the-request-object","text":"The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.)","title":"The Request Object"},{"location":"components/#the-pager","text":"The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it.","title":"The Pager"},{"location":"components/#custom-forms","text":"The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form .","title":"Custom Forms"},{"location":"components/#views","text":"Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup.","title":"Views"},{"location":"components/#models","text":"The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM.","title":"Models"},{"location":"components/#web-and-api-handlers","text":"All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file .","title":"Web and API Handlers"},{"location":"components/#ui-components-page","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"UI Components Page"},{"location":"database/","text":"The Registry Database","title":"Database"},{"location":"database/#the-registry-database","text":"","title":"The Registry Database"},{"location":"deletion/","text":"File and Object Deletion","title":"Deletion"},{"location":"deletion/#file-and-object-deletion","text":"","title":"File and Object Deletion"},{"location":"features/","text":"Features","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"institution-management/","text":"Institution Management","title":"Institution Management"},{"location":"institution-management/#institution-management","text":"","title":"Institution Management"},{"location":"nsq/","text":"NSQ The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once. Definitions A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic. Pausing and Unpausing Topics Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons. Emptying Topics and Channels With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"NSQ"},{"location":"nsq/#nsq","text":"The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once.","title":"NSQ"},{"location":"nsq/#definitions","text":"A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic.","title":"Definitions"},{"location":"nsq/#pausing-and-unpausing-topics","text":"Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons.","title":"Pausing and Unpausing Topics"},{"location":"nsq/#emptying-topics-and-channels","text":"With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"Emptying Topics and Channels"},{"location":"requests/","text":"Requests","title":"Requests"},{"location":"requests/#requests","text":"","title":"Requests"},{"location":"requeuing/","text":"Requeuing WorkItems","title":"Requeing Work Items"},{"location":"requeuing/#requeuing-workitems","text":"","title":"Requeuing WorkItems"},{"location":"restoration/","text":"File and Object Restoration","title":"Restoration"},{"location":"restoration/#file-and-object-restoration","text":"","title":"File and Object Restoration"},{"location":"settings/","text":"Settings Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD Setting Definitions Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Settings"},{"location":"settings/#settings","text":"Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD","title":"Settings"},{"location":"settings/#setting-definitions","text":"Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Setting Definitions"},{"location":"structure/","text":"Code Structure The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"structure/#code-structure","text":"The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"testing/","text":"Testing To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up. Thorough Testing Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Testing"},{"location":"testing/#testing","text":"To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up.","title":"Testing"},{"location":"testing/#thorough-testing","text":"Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Thorough Testing"},{"location":"ui-components/","text":"UI Components The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"ui-components/#ui-components","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"user-management/","text":"User Management","title":"User Management"},{"location":"user-management/#user-management","text":"","title":"User Management"},{"location":"security/","text":"Security Overview Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rais devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler.","title":"Security Overview"},{"location":"security/#security-overview","text":"Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rais devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler.","title":"Security Overview"},{"location":"security/authentication/","text":"Authentication Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API.","title":"Authentication"},{"location":"security/authentication/#authentication","text":"Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API.","title":"Authentication"},{"location":"security/authorization/","text":"Authorization","title":"Authorization"},{"location":"security/authorization/#authorization","text":"","title":"Authorization"},{"location":"security/csrf/","text":"Cross-Site Request Forgery","title":"Cross-Site Request Forgery"},{"location":"security/csrf/#cross-site-request-forgery","text":"","title":"Cross-Site Request Forgery"}]}