{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The APTrust Registry The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests. External Components & Services The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"Home"},{"location":"#the-aptrust-registry","text":"The APTrust Registry is a web application and REST API providing information about what we've stored in our preservation repository. The web application lets depositors find, restore, and delete intellectual objects and generic files. It also shows the status of work items (i.e. ingests, restoration and deletion requests), and provides basic user management functions to local institutional admins. The member API provides read-only access to objects, files, work items and related records to APTrust depositors. The admin API provides read-write access to Preserv service workers that process ingests, restorations, fixity checks and deletions. Preserv is the Registry's most active client. Fixity checks typically issue 10,000+ requests per hour. A slow ingest day may result in only a few hundred API requests, while a very busy day may result in a million or so requests.","title":"The APTrust Registry"},{"location":"#external-components-services","text":"The Registry is written in Go, using the Gin web framework. The application runs inside Docker containers in Amazon's ECS/Fargate service. It tends to be light on memory and heavy on CPU when under load. ECS will add Registry containers when CPU usages passes a certain threshold and scale them back as load decreases. It stores persistent data in a Postgres database running on Amazon's RDS, using go-pg as an object-relational mapper. While the Registry handles incoming requests from web browsers, member API consumers around the country, and from Preserv, it also establishes outbound connections to the following services: Service Description Postgres The main, long-term data store containing info about all objects and files stored in preservation buckets, plus their associated checksums, storage records and Premis events. The Postgres DB also contains user and institutional account records and info about work items. Authy Used to send push notifications for multifactor authentication. NSQ This queue service pushes work items to the Preserv workers that carry out the actual work. Registry sends Deletion and Restoration requests to NSQ in response to user actions in the Web UI. Redis Registry reads JSON data from Redis describing the state of long-running ingest processes. Registry can also delete Redis data on demand when requeuing Work Items. Redis data is available to APTrust admins only. Amazon SES Registry sends alerts and password-reset messages via email through Amazon's Simple Email Service. Amazon SNS Registry sends one-time passwords in text messages through Amazon's SNS service. This is for multifactor authentication.","title":"External Components &amp; Services"},{"location":"components/","text":"Code Components The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages. The Application File The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries. Template Helpers The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go Constants constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied. The Configuration Object The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below. The Context Object The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message. Security Middleware Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle. The Request Object The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.) The Pager The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it. Custom Forms The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form . Views Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup. Models The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM. Web and API Handlers All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file . UI Components Page The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"Key Code Components"},{"location":"components/#code-components","text":"The Registry app is built primarily on the Gin web framework and the go-pg ORM for Postgres. Additional packages (listed in go.mod) include: aws-sdk-go for SES and SNS services (but not for S3 or Glacier) go-authy for authy push notifications used in two-factor login govalidator for data validation httpexpect for testing web and API requests nsq for talking to NSQ services redis for talking to Redis/Elasticache testify for unit and integration tests viper for reading config settings zerolog for logging The headings below give a high-level overview of key files and components, describing where to find them, what they do, and how they fit into the system. This page attempts to give an overview only. Components are described in more detail on dedicated pages.","title":"Code Components"},{"location":"components/#the-application-file","text":"The application file includes essential setup and configuration steps to run the Registry app. This includes: Defining routes for the web UI, member API and admin API. Defining template helpers, which are functions that can be executed within HTML templates. Running code to load all HTML templates at application start. Initializing midleware. The application file defined a single public function called Run() which runs the Registry service. This function is called in registry.go to start the server. It's also called in the test suite to run a background server to handle test queries.","title":"The Application File"},{"location":"components/#template-helpers","text":"The templates.go file defines a number of helper functions that can be called from within the application's HTML templates. The functions' names will tell you what they do. Each function also includes a docstring. Note that these functions must be registered to work inside of templates. The registration happens in the initTeplates() function in app/application.go","title":"Template Helpers"},{"location":"components/#constants","text":"constant.go defines a number of constants used througout the app. This is to avoid having the app littered with mistyped strings or strings whose cases don't match. The constants' names are descriptive enough to tell you what they mean. permissions.go defines permissions and which roles they are assigned to. See the Authorization page for details on how permissions are applied.","title":"Constants"},{"location":"components/#the-configuration-object","text":"The Configuration Object loads config variables from a .env file and from environment variables, which can be pumped into Docker containers from Amazon's Parameter Store. In development and test environments, most config settings are stored in .dev.env or .test.env. To load the right config, specify one of the following on the command line: APT_ENV=dev ./registry serve or APT_ENV=test ./registry serve Config settings are loaded first from the .env file, then from the environment, with environment values overwriting .env file values via viper's AutomaticEnv() call. The environment is loaded and made globally available by the Context() function , which returns a singleton instance of APTContext, described below.","title":"The Configuration Object"},{"location":"components/#the-context-object","text":"The Context() function returns a singleton instance of APTContext, which makes the following items available to all parts of the Registry application: A Configuration object containing all config settings. A DB object which provides a connection pool to the Postgres database. A Log object for logging. An AuthyClient for two-factor auth push notifications. A RedisClient for talking to Redis. An NSQClient for talking to NSQ. An SESClient for sending emails to users. These are usually password-reset emails, or emails asking someone to review a deletion request. An SNSClient for sending login codes to two-factor auth users via text message.","title":"The Context Object"},{"location":"components/#security-middleware","text":"Sucurity middleware is registered in the application file . The source is in the middleware directory . Each piece of middleware touches every request before the registered request handler. The components have the following responsibilities: Compenent Responsibility authenticate.go Ensures the current user is authenticated before accessing endpoints that require authentication. authorize.go Ensures the user is authorized to perform the current request. This component depends on the authorization_map.go and resource_authorization.go files in the middleware directory, as well as the permissions.go file in the constants directory. csrf.go This ensures that CSRF tokens are present and valid for all POST and PUT requests. See the Security Overview for info on how security checks fit into the request lifecycle.","title":"Security Middleware"},{"location":"components/#the-request-object","text":"The Request object handles boilerplate processing common to all requests, such as parsing common query data, loading common tempdate data value, showing or hiding submenus, setting up a pager for list responses, and loading requested objects or lists of objects. There are two versions of the request object: one for web requests and one for API requests . You'll notice in that in both the Web UI and the REST APIs, most handlers begin with a call to req := NewRequest(c) to handle the boilerplate setup. (The c param is the *gin.Context object, which contains the HTTP request and lots of other metadata.)","title":"The Request Object"},{"location":"components/#the-pager","text":"The pager object contains information about lists, including how many total results a list query yielded and links to the next and previous pages of results. This object works for both Web (HTML) and API (JSON) requests. Because this object is automatically set up by the Request object, you generally don't have to touch it or think about it.","title":"The Pager"},{"location":"components/#custom-forms","text":"The forms directory defines custom forms for each type of object a user or admin may edit through the web UI. It also contains filter forms for all of the Web UI's list pages. The form objects define what goes into each form. Forms layout and rendering is defined in the views directory . For example, the form for editing user details is in the user form template . while the for for filtering a list of users in in the user filters form .","title":"Custom Forms"},{"location":"components/#views","text":"Views are HTML templates used to render web pages. All of the Registry's views are in the views directory . The application file loads all of them at startup.","title":"Views"},{"location":"components/#models","text":"The application models are defind in the pgmodels directory . These models map to database tables and views through the go-pg ORM.","title":"Models"},{"location":"components/#web-and-api-handlers","text":"All of the handlers for the Web UI are defined in the web/webui directory . Handlers for the member API, which is a read-only subset of the admin API, are in the web/api/common directory. Handlers for the admin API are in the web/api/admin directory. These handlers are mapped to URLs in the application file .","title":"Web and API Handlers"},{"location":"components/#ui-components-page","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features.","title":"UI Components Page"},{"location":"database/","text":"The Registry Database","title":"Database"},{"location":"database/#the-registry-database","text":"","title":"The Registry Database"},{"location":"deletion/","text":"File and Object Deletion","title":"Deletion"},{"location":"deletion/#file-and-object-deletion","text":"","title":"File and Object Deletion"},{"location":"features/","text":"Features","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"institution-management/","text":"Institution Management","title":"Institution Management"},{"location":"institution-management/#institution-management","text":"","title":"Institution Management"},{"location":"nsq/","text":"NSQ The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once. Definitions A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic. Pausing and Unpausing Topics Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons. Emptying Topics and Channels With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"NSQ"},{"location":"nsq/#nsq","text":"The Registry provides access to NSQ, so APTrust admins can see the status of queues and topics. We expose NSQ here, rather than on the public internet, so outsiders can't access its admin panel. (Hint: You'll find it in Registry's left sidebar, under More Options > NSQ .) The NSQ admin panel shows you info about nsqd's basic health, including where it's running and how many workers are listening on each channel. It also provides controls to pause, unpause, and empty individual topics and channels, or all topics and channels at once.","title":"NSQ"},{"location":"nsq/#definitions","text":"A topic receives tasks as inputs. For example, when Preserv's bucket reader finds new tar files in depositors' receiving buckets, it creates a WorkItem in Registry and adds the WorkItem ID to the ingest01_prefetch topic. Workers listen on channels , through which nsqd pushes WorkItems to the listening workers. For example, Preserv's ingest_pre_fetch worker listens to the ingest_pre_fetch_worker_chan , where it picks up WorkItem IDs. NSQ supports multiple channels per topic, because in many other environments, it's common for more than one worker to have to act on items in a given topic. In APTrust's system, we have only one channel per topic.","title":"Definitions"},{"location":"nsq/#pausing-and-unpausing-topics","text":"Pausing topics and channels will cause NSQ to continue to queue new incoming tasks while preventing it from farming those tasks out to workers. Pausing topics and channels makes sense under the following circumstances: A worker has a known bug, and you want to stop it from touching data until you can deploy a fix. You need to run a database migration, and you want all processing to stop until the migration completes. You are replacing some piece of infrastructure and you want processing to stop until the new hardware/service is ready. (This was common in our old Exchange architecture and should happen rarely or never in Preserv.) The NSQ admin page includes buttons to pause all topics and all channels to simplify this process. Warning Once you have paused topics and channels, you need to check the NSQ admin panel periodically to ensure that no items are in flight in any of the paused queues. Until the in-flight count hits zero on all of the paused topics and queues, you must assume Preserv is still reading from and writing to Registry. Running database migrations is unsafe until all in-flight counts are zero. When you've completed your disruptive work, you can unpause topics and queues, and Preserv will continue its work. If you paused multiple topics and queues, the easiest way to unpause them is to use the \"Unpause All\" buttons.","title":"Pausing and Unpausing Topics"},{"location":"nsq/#emptying-topics-and-channels","text":"With the exception of the fixity check topic, you shouldn't empty topics without a very good reason. If you do empty one, you will likely have to manually requeue everything that was in there through the WorkItem web UI. (Those items will appear as stalled in the last phase of processing, and they won't move again until you requeue them.) It is always safe to empty the fixity_check topic, and this is likely the only topic you will have cause to empty. The apt_queue_fixity worker pumps about 2,500 items into the fixity topic every half hour. These will be the first 2,500 files it finds that have not had a fixity check in at least 90 days. If any kind of outage prevents the fixity checker from doing its work, apt_queue_fixity will keep queuing the same 2,500 items every half hour. If a network outage or S3 service outage lasts for a few hours (this happens, but it's rare), the fixity_check channel may accumulate a backlog of tens of thousands of items--and they'll be the same items queued again and again. When the fixity checker resumes its work, it will check with registry to ensure that each queued item really does still need a fixity check, and it will skip the check if it's no longer required. In practice, this amounts to the fixity checker calculating fixity on 2,500 items, and then sending tens of thousands of requests to Registry asking if the next item still needs a check. Registry has to answer \"No\" tens of thousands of times, and this amounts to a mini denial of service attack. When you run into this situation (again, it's rare), keep in mind that it is always safe to empty the fixity_check topic. Whatever meaningful items were in that topic will be put back in the next time apt_queue_fixity runs.","title":"Emptying Topics and Channels"},{"location":"requests/","text":"Requests","title":"Requests"},{"location":"requests/#requests","text":"","title":"Requests"},{"location":"requeuing/","text":"Requeuing WorkItems","title":"Requeing Work Items"},{"location":"requeuing/#requeuing-workitems","text":"","title":"Requeuing WorkItems"},{"location":"restoration/","text":"File and Object Restoration","title":"Restoration"},{"location":"restoration/#file-and-object-restoration","text":"","title":"File and Object Restoration"},{"location":"settings/","text":"Settings Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD Setting Definitions Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Settings"},{"location":"settings/#settings","text":"Registry loads settings into its config object the first time the common.Context() function is called. Registry loads settings from the .env file whose name matched the APT_ENV environment variable. For example, if APT_ENV=dev , Registry will load settings from the .env.dev file in the top level directory of the Registry project. If APT_ENV=test , it will load .env.test . After loading settings from the file, the config object loads them from the environment using Viper's AutomaticEnv() function. Values loaded from the environment override values defined in the .env file. This is handy in Fargate/ECS because we can store sensitive settings, such as database credentials, in Amazon's Parameter Store. Before ECS starts the Registry's Docker container, it runs a sidecar process to load environment variables from Parameter Store. Those variables are then available in the environment when Registry starts, and the config object can read them. Danger Store sensitive credentials in your local environment for dev and test, or in parameter store for live environments. Otherwise, you risk accidentally leaking credentials, most likely in a GitHub commit. Sentive credentials include: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COOKIE_BLOCK_KEY COOKIE_HASH_KEY DB_HOST DB_USER DB_PASSWORD REDIS_PASSWORD","title":"Settings"},{"location":"settings/#setting-definitions","text":"Name Description AWS_ACCESS_KEY_ID AWS access key for connecting to SES and SNS services. AWS_REGION The AWS region to connect to for SES and SNS services. This should be the same region Registry runs in, which is us-east-1a . AWS_SECRET_ACCESS_KEY The AWS secret key for connecting to SES and SNS services. COOKIE BLOCK_KEY Used along with COOKIE_HASH_KEY to encrypt cookies stored in the user's browser. COOKIE_DOMAIN The name of the domain that can set and read cookies. For development and test, this should be localhost . For live environments, it should match the fully qualified domain name, e.g. staging.aptrust.org . COOKIE_HASH_KEY Used along with COOKIE_BLOCK_KEY to encrypt cookies stored in the user's browser. DB_DRIVER The name of the dabase driver. This should always be postgres . DB_HOST The name of the databse host. For dev and test, this should be localhost . For live environments, it should be the fully qualified domain name or internal private hostname of the RDS instance that hosts our postgres database. DB_NAME The name of the database. E.g. apt_registry_test or pharos_demo . DB_PASSWORD The password to connect to the postgres database. DB_PORT The postgres database port. Usually 5432. DB_USER The username to connect to the postgres database. DB_USE_SSL Should we use SSL when connecting to the database? For localhost connections, this is usually false. For RDS connections, it should be true. EMAIL_ENABLED Set this to true on all live systems and to false for dev and test systems. When set to false, Registry will print the contents of emails to STDOUT. This is helpful for testing \"forgot password\" emails and deletion confirmation emails. EMAIL_FROM_ADDRESS The from address to attach to all system-generated emails. Typically, this is help@aptrust.org . ENABLE_TWO_FACTOR_AUTHY Set this to true in live systems and false in dev and test systems. ENABLE_TWO_FACTOR_SMS Set this to true in live systems and false in dev and test systems. When set to false, Registry will print two-factor SMS codes to STDOUT so developers can complete the login process. FLASH_COOKIE_NAME The name of the cookie used to display transient notifications in the web UI. HTTPS_COOKIES Set this to true on live systems that use HTTPS connections, and to false for dev and test setups that run on localhost. LOG_CALLER When true, this logs additional information about the calling function in certain log messages. For live systems, this should be false, unless we're debugging difficult issues. LOG_FILE The path to the file where Registry should write its log statements. Setting this STDOUT causes Registry to log to STDOUT. On live systems, set this to STDOUT so the logs go into CloudWatch. LOG_LEVEL This describes how detailed the logs should be. For production systems, we generally want 1 (info). For dev and test systems, 0 (debug) will provide additional information. Allowed values are: -1: Trace, 0: Debug, 1: Info, 2: Warn, 3: Error, 4: Fatal, 5: Panic, 6: None, 7: Disabled LOG_SQL If true, Registry will log all SQL statements. We almost always want this set to false because it produces massive logs. Use this only to debug tricky SQL issues. LOG_TO_CONSOLE If true, Registry will log to the console as well as to the log file. On live systems (prod, demo, staging), this should be false because we log to STDOUT anyway. On dev and test systems, you can set this to true to watch the logs in your console as you interact with Registry. NSQ_URL The URL of the NSQ service. Note that NSQ usually runs three processes (nsqd, nsqlookupd, and nsqadmin) on three different ports. The one you want here is nsqd, which runs on port 4151. On a local dev machine, this will be http://localhost:4151 OTP_EXPIRATION The time before a two-factor OTP token expires. These tokens are sent via SMS. This setting uses Go's time notation, so 90s is 90 seconds, 15m is 15 minutes, 1h is one hour. PREFS_COOKIE_NAME The name of Registry's preferences cookie. This is not yet in use, but may be in future. REDIS_DEFAULT_DB The default Redis database we want to connect to. This is a numeric value between 0-15, and is almost always 0 (zero). REDIS_PASSWORD The password used to connect to the Redis database. REDIS_URL The URL of the Redis server to connect to. This should include a hostname and port, but not a protocol. E.g. localhost:6379 . SESSION_COOKIE_NAME The name of the Registry's session cookie. SESSION_MAX_AGE The maximum time, in seconds, that the session cookie can live. This is usually set between 86400 (one day) and 604800 (seven days). Note that this setting actually applies to all cookies.","title":"Setting Definitions"},{"location":"structure/","text":"Code Structure The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"structure/#code-structure","text":"The Registry's GitHub repository contains the follwing directories and files: Name Description .github/workflows Just what it says. Workflows including mirroring code to Gitlab. .vscode Contains a barbones launch.json file telling VS Code how the launch the Registry app. alert_templates Contains a set of text templates used to send email alerts to Registry users. app Contains the main application.go file that defines routes, template helpers, and initializes middleware. bin Contains NSQ and Redis binaries to run external services on Mac and Linux. These are required for testing. See bin/README.md for details. cfn Contains CloudFormation templates for deploying Registry to Fargate. The key files are cfn-registry-cluster.tmpl , which is a template for the deployment file, and cfn-registry-cluster.yml , which is the actual deployment file. common Contains code commonly used by other components throughout the Registry app. The most important of these are the Configuration Object and the Context Object . constants Defines constants.go used throughout the application and permissions.go defining which roles can do what. We don't put permissions in the database because we want them to be immutable. db Contains the database schema, migrations, fixitures, and some utility functions to load fixtures for testing. docs Contains wireframes used in the UI design process. forms Defines objects used to render, validate and parse form data. helpers Defines a number of helper functions used in text and HTML templates. loader Contains code for a standalone app to load database fixtures. middleware Contains code for user authentication and authorization, and resource setup used in virtually all web and API requests. network Contains code for clients that talk to external services, including Authy, NSQ, Redis, and Amazon's SES (Email) and SNS (Text/SMS). pgmodels Defines the data models for items stored in the Postgres database. static Contains statically served web resources, including scripts, stylesheets and images. swagger Contains the output of the Swagger documentation generator. This output is served on our Swagger doc site views Contains HTML templates for all pages in the Web UI. web Contains handlers for web requests. Read on... web/api Contains handlers for API requests. web/api/admin Contains handlers specific to the admin API, which is the read-write API used by Preserv to process ingests, deletions, restorations and fixity checks. web/api/common Contains handlers for the read-only member API. Some of these handlers are also used by the admin API. See the routing table in app/application.go web/testutil Contains utilities for testing the web UI and REST APIs. web/webui Contains handlers for web UI requests. .env files Contain settings used in various environments (dev, test, etc.) Dockerfile Describes how to build Registry's Docker container. Dockerfile.multi ? Makefile Contains build commands to create the Docker container and update the CloudFormation deployment template. member_api_v3.yml Contains a description of the API used to generate Swagger docs. registry A shell script used to run and/or test the Registry. ./registry serve runs an instance of the Registry on localhost:8080 (along with NSQ and Redis). ./registry test runs the test suite. registry.go The file from which the Registry binary is compiled. Its main() method creates an instance of the app and runs it, listening on port 8080.","title":"Code Structure"},{"location":"testing/","text":"Testing To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up. Thorough Testing Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Testing"},{"location":"testing/#testing","text":"To run the Registry's unit tests, simply run ./registry test from the project's top-level directory. Note that /registry is a bash script. When run with the test argument, it does the following: Starts a local instance of Registry. Starts a local instance of NSQ. Starts a local instance of Redis. Runs unit tests. Runs basic integration tests with NSQ and Redis. The Redis and NSQ binaries are stored in the project's bin directory, under bin/linux and bin/osx . Note The Registry test suite assumes you have a Registry database running inside a local Postgres instance. If you don't see the Registry README for info on how to set one up.","title":"Testing"},{"location":"testing/#thorough-testing","text":"Registry's unit and integration tests will tell you whether the system's basic functions are operating as expected, and they will generally catch regressions caused by new or updated code. These tests, however, do not really tell you how Registry will behave in the context of a fully-functioning APTrust environment. Registry's ability to interact correctly with Preservation Services is the most important thing to ensure, and for that, you'll need to run Preserv's integration and end-to-end test suites. For more on that, see the Preserv testing guide . Important If you make any changes to Registry that may affect its interaction with Preserv, run the Preserv integration and end-to-end tests before committing your new code to the master branch.","title":"Thorough Testing"},{"location":"ui-components/","text":"UI Components The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"ui-components/#ui-components","text":"The UI components page displays available UI components and the HTML required to render them. Refer to this page when creating new features or pages.","title":"UI Components"},{"location":"user-management/","text":"User Management","title":"User Management"},{"location":"user-management/#user-management","text":"","title":"User Management"},{"location":"security/","text":"Security Overview Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rails devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler. About Middleware The Gin web framework allows us to define middleware that executes before (and after) a request reaches our application's request handlers. The initMiddleware() function in application.go defines four middlewares to be executed in order. The first is a general logger. It always passes control to the next middlware, which is Authentication . If the authentication middleware determines the current user can proceed with the request, it passes control to the next middleware, which is authorization. If the authenticated middleware determines the user cannot proceed with the request (because the request requires authentication and the user is missing a valid session cookie), it sends an error response and the request ends there. It never even reaches the authorization step. The Authorization middleware checks to see if the user is authorized to perform the requested action or to access the requested resource. If so, it passes the request on to the CSRF middleware. If not, request processing ends here, with the middleware returning an error response to the user. If the user is attempting a PUT or POST request, the CSRF middleware ensures that the request includes valid CSRF tokens. If a token is missing from the cookie or the form, or if the tokens don't match, processing end here with the CSRF middleware returning an error response. Middlewares push requests to the next step of processing by calling the Next() function. Note that middlewares can touch the response object in the Gin context after calling Next() , though Registry does not do this. Maintainers can add post-processing in future generations of Registry if necessary.","title":"Security Overview"},{"location":"security/#security-overview","text":"Registry's security system has three main components. Click on any link to learn more. Authentication handles user logins, two-factor auth functions, and request-level identity verification. Authorization handles endpoint and resource-level permission checks. CSRF handles tokens to prevent cross-site request forgery (CSRF). Aside from user login, all of these security features are implemented in middleware to ensure that security checks run before any request is handled. If any request hits an endpoint without first getting explicit approval from security middleware, the application will return an error and the request handler will not be called. This pattern, inspired by the Rails devise gem, puts the onus on the developer to ensure security checks occur for each request. If the developer forgets to explicit add a security for a new request handler, no one will ever be able to reach that handler.","title":"Security Overview"},{"location":"security/#about-middleware","text":"The Gin web framework allows us to define middleware that executes before (and after) a request reaches our application's request handlers. The initMiddleware() function in application.go defines four middlewares to be executed in order. The first is a general logger. It always passes control to the next middlware, which is Authentication . If the authentication middleware determines the current user can proceed with the request, it passes control to the next middleware, which is authorization. If the authenticated middleware determines the user cannot proceed with the request (because the request requires authentication and the user is missing a valid session cookie), it sends an error response and the request ends there. It never even reaches the authorization step. The Authorization middleware checks to see if the user is authorized to perform the requested action or to access the requested resource. If so, it passes the request on to the CSRF middleware. If not, request processing ends here, with the middleware returning an error response to the user. If the user is attempting a PUT or POST request, the CSRF middleware ensures that the request includes valid CSRF tokens. If a token is missing from the cookie or the form, or if the tokens don't match, processing end here with the CSRF middleware returning an error response. Middlewares push requests to the next step of processing by calling the Next() function. Note that middlewares can touch the response object in the Gin context after calling Next() , though Registry does not do this. Maintainers can add post-processing in future generations of Registry if necessary.","title":"About Middleware"},{"location":"security/authentication/","text":"Authentication Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API. Web UI While the UserSignInShow() and UserSignIn() methods of the Users Controller handle the sign-in process, the Authentication middleware checks the session cookie on subsequent requests. The session cookie contains an encrypted User ID, which the authentication middleware uses to look up the user record. It then stores the User object in the Gin context for later access. The authentication middleware ensures the following: That the request includes a valid user session cookie with a valid user if the request tries to access a protected resource. See below for a list of resources that do not require authentication. That the user will be forced to complete the password change process before accessing any other resources, if the user happens to be in the middle of the password change process. That the user will be forced to complete the second step of two-factor authentication before accessing any other resources, if they have logged in with their email and password and have not yet completed the second step of two-factor auth. Endpoints Exempt from Authorization The middleware/authentication.go includes a function called ExemptFromAuth() to check whether the current request is exempt from authentication. Currently, the following endpoints are exempt: Endpoint Explanation /users/sign_in Users obviously won't be logged in when they go to the sign-in page. They have to be able to see it to log in. /users/sign_out This page tells the user they've signed out. /users/forgot_password This page is for users who have forgotten their password and received a password-reset email. The page includes a text input for them to enter the password reset token we sent them. /users/complete_password_reset/ After entering their reset token, users choose a new password on this page. The app includes security measures to prevent people accessing this page without having previously entered the reset token. /ui-components This page displays a gallery of UI components, for developer reference. It's static and contains no sensitive information. /static/* This is the prefix for all static resources, including scripts, stylesheets, icons and fonts. /favicon/* This returns the site's favicon. /error This page displayes errors, including errors telling you you need to log in. API If the Authentication middleware detects that the user has requested an API endpoint rather than a web endpoint, the GetUserFromAPIHeaders() function extracts the header values for X-Pharos-API-User and X-Pharos-API-Key and loads the user based on their API key. Default Headers The Authentication middleware also sets some default headers for every request. We want to set these here because we want to those headers even when authenticaion fails and the auth middleware responds directly to the user. We set the following headers in SetDefaultHeaders() : Name Value Description Cache-Control no-cache Tells browsers and proxies not to cache responses. This is set only for dynamic content, not for static content like scripts, stylesheets and images. Pragma no-store Same as Cache-Control above, but for really old browsers. Strict-Transport-Security max-age=31536000 Forces clients to use HTTPS instead of HTTP. X-XSS-Protection 1 Instructs browsers to stop loading or sanitize the page if they detect a cross-site scripting attack. X-Content-Type-Options \"nosniff\" Blocks content sniffing that could transform non-executable MIME types into executable MIME types. Content-Security-Policy \"default-src 'self'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com; script-src 'self' 'unsafe-inline'\" Prevents some cross-site scripting and data injection attacks. The policy spelled out in the value of this header says the browser should trust scripts, fonts, and stylesheets from our own domain. It should also accept fonts from Google's font serving domain, fonts.gstatic.com and CSS from fonts.googlapis.com. The unsafe-inline statements mean the browser should trust inline JavaScript from our domain and inline CSS from fonts.googleapis.com. Confirming browsers will reject fonts, scripts, and stylesheets from other sources.","title":"Authentication"},{"location":"security/authentication/#authentication","text":"Registry supports two types of authentication: a sign-in based scheme for users accessing the Web UI and a token-based scheme for API consumers accessing the member or admin API.","title":"Authentication"},{"location":"security/authentication/#web-ui","text":"While the UserSignInShow() and UserSignIn() methods of the Users Controller handle the sign-in process, the Authentication middleware checks the session cookie on subsequent requests. The session cookie contains an encrypted User ID, which the authentication middleware uses to look up the user record. It then stores the User object in the Gin context for later access. The authentication middleware ensures the following: That the request includes a valid user session cookie with a valid user if the request tries to access a protected resource. See below for a list of resources that do not require authentication. That the user will be forced to complete the password change process before accessing any other resources, if the user happens to be in the middle of the password change process. That the user will be forced to complete the second step of two-factor authentication before accessing any other resources, if they have logged in with their email and password and have not yet completed the second step of two-factor auth.","title":"Web UI"},{"location":"security/authentication/#endpoints-exempt-from-authorization","text":"The middleware/authentication.go includes a function called ExemptFromAuth() to check whether the current request is exempt from authentication. Currently, the following endpoints are exempt: Endpoint Explanation /users/sign_in Users obviously won't be logged in when they go to the sign-in page. They have to be able to see it to log in. /users/sign_out This page tells the user they've signed out. /users/forgot_password This page is for users who have forgotten their password and received a password-reset email. The page includes a text input for them to enter the password reset token we sent them. /users/complete_password_reset/ After entering their reset token, users choose a new password on this page. The app includes security measures to prevent people accessing this page without having previously entered the reset token. /ui-components This page displays a gallery of UI components, for developer reference. It's static and contains no sensitive information. /static/* This is the prefix for all static resources, including scripts, stylesheets, icons and fonts. /favicon/* This returns the site's favicon. /error This page displayes errors, including errors telling you you need to log in.","title":"Endpoints Exempt from Authorization"},{"location":"security/authentication/#api","text":"If the Authentication middleware detects that the user has requested an API endpoint rather than a web endpoint, the GetUserFromAPIHeaders() function extracts the header values for X-Pharos-API-User and X-Pharos-API-Key and loads the user based on their API key.","title":"API"},{"location":"security/authentication/#default-headers","text":"The Authentication middleware also sets some default headers for every request. We want to set these here because we want to those headers even when authenticaion fails and the auth middleware responds directly to the user. We set the following headers in SetDefaultHeaders() : Name Value Description Cache-Control no-cache Tells browsers and proxies not to cache responses. This is set only for dynamic content, not for static content like scripts, stylesheets and images. Pragma no-store Same as Cache-Control above, but for really old browsers. Strict-Transport-Security max-age=31536000 Forces clients to use HTTPS instead of HTTP. X-XSS-Protection 1 Instructs browsers to stop loading or sanitize the page if they detect a cross-site scripting attack. X-Content-Type-Options \"nosniff\" Blocks content sniffing that could transform non-executable MIME types into executable MIME types. Content-Security-Policy \"default-src 'self'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline' fonts.googleapis.com; script-src 'self' 'unsafe-inline'\" Prevents some cross-site scripting and data injection attacks. The policy spelled out in the value of this header says the browser should trust scripts, fonts, and stylesheets from our own domain. It should also accept fonts from Google's font serving domain, fonts.gstatic.com and CSS from fonts.googlapis.com. The unsafe-inline statements mean the browser should trust inline JavaScript from our domain and inline CSS from fonts.googleapis.com. Confirming browsers will reject fonts, scripts, and stylesheets from other sources.","title":"Default Headers"},{"location":"security/authorization/","text":"Authorization Authorization middleware runs after authentication middleware. By the time it touches the request, the authentication middlware has added the User object to the current request. The authorization middlware uses that User object to do the following: Check the URL/request path to see what type of resource the user is requesting. If the resource maps to a specific database record (a work item, generic file, intellectual object, etc.), it looks up the record to see which institution it belongs to. Check the authrorization map to see if the user is allowed to access that particular resource belonging to that particular institution. Constructs a ResourceAuthorization object with the following information: Handler - The name of the HTTP handler function that will handle the user's request. ResourceID - The unique id of the resource (work item, file, obect, etc.) the user requested. This will be zero if the user is requesting a list of items. ResourceIdentifier - The string identifier of the requested resource. This applies to institutions, intellectual objects and generic files. ResourceInstId - The ID of the institution to which the resource belongs. ResourceType - The type of resource (IntellectualObject, WorkItem, GenericFile, etc.). Permission - The permission required to access the requested resource. These are defined in constants/permissions . Checked - True or false, indicating whether the authorization middleware checked that the user has permission to access the requested resource. Approved - True or false, indicating whether the user has permission to access the requested resource. Error - Describes any error that occurred during the authorization check. The authorization middleware will not let a request proceed unless the ResourceAuthorization object's Checked and Approved attrbutes are both true. Things to Note If, when adding a new endpoint, you to forget to define a permission for it, you will never be able to reach that endpoint, because without a defined permission, ResourceAuthorization.Checked will be false. Requests for list endpoints, such as the WorkItems list and the IntellectualObject list, cannot include a ResourceID or a ResourceInstID, because the requests don't target a single resource. Unless the requesting user is an APTrust admin, database queries issued by these requests will always include an Institution ID filter, with the ID set to the user's own institution ID. For example, when a user from virginia.edu requests a list of WorkItems, objects, or files, the system will force a where clause into their queries stating where institution_id = [user's institution id] . This occurs in the LoadResourceList() function of the Web UI's Request object and in the LoadResourceList() function of the API's Request object . Permission Definitions All of Registry's permission are defined in constants/permissions.go . The initPermissions() function in that file assigns permissions to roles like so: // Institutional User Role instUser [ ChecksumRead ] = true instUser [ DashboardShow ] = true // ... additional permissions omitted for brevity... // Institutional Admin Role instAdmin [ FileDelete ] = true instAdmin [ FileRead ] = true // ... additional permissions omitted for brevity... // Sys Admin Role sysAdmin [ ChecksumCreate ] = true sysAdmin [ ChecksumDelete ] = false // no one can do this sysAdmin [ ChecksumRead ] = true // ... additional permissions omitted for brevity... Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. Important No role has any permission unless it is explicitly granted in constants/permissions.go , and some permissions are explicitly denied to all users because they violate business rules. For example, no user can delete checksums or delete or alter PREMIS events. The endpoints to perform these actions don't even exist, and the underlying data models will throw errors if anyone even tries to perform these actions. Permission Mapping While permissions are defined and assigned to roles in constants/permissions.go , they are mapped to request handlers in middleware/authorization_map.go . The authorization map tells the app which permission is required to access each request handler. Important If you don't map a permission to your new request handler, no one will be able to reach it, ever, because the authorization check will fail. Permission Checking The middleware/authorization.go middleware figures out which request handler responds to the current URL. It reads the authorization map to see which permission is required to access that handler, then determines whether the current user is allowed to call that handler. It also does further checks, as described above, to see if the user can access whatever resources that handler touches. List of Authorization-Related Files File Description constants/permissions.go Defines all of the system permissions and assigns them to roles at application start. middleware/authorization_map.go Maps permissions to web and API request handlers. middleware/authorize.go Authorizes requests and decides whether or not to pass the request on to the handler. middleware/resource_authorization.go Includes logic to compare user permissions to the authorization map, and to do fine-grained resource-level checks. (I.e. Ensures objects user is requesting actually belong to that user's institution.) web/webui/request.go Enforces filters in list requests to ensure users access only resources belonging to their own institution. web/api/request/go Enforces filters in API list requests to ensure users access only resources belonging to their own institution.","title":"Authorization"},{"location":"security/authorization/#authorization","text":"Authorization middleware runs after authentication middleware. By the time it touches the request, the authentication middlware has added the User object to the current request. The authorization middlware uses that User object to do the following: Check the URL/request path to see what type of resource the user is requesting. If the resource maps to a specific database record (a work item, generic file, intellectual object, etc.), it looks up the record to see which institution it belongs to. Check the authrorization map to see if the user is allowed to access that particular resource belonging to that particular institution. Constructs a ResourceAuthorization object with the following information: Handler - The name of the HTTP handler function that will handle the user's request. ResourceID - The unique id of the resource (work item, file, obect, etc.) the user requested. This will be zero if the user is requesting a list of items. ResourceIdentifier - The string identifier of the requested resource. This applies to institutions, intellectual objects and generic files. ResourceInstId - The ID of the institution to which the resource belongs. ResourceType - The type of resource (IntellectualObject, WorkItem, GenericFile, etc.). Permission - The permission required to access the requested resource. These are defined in constants/permissions . Checked - True or false, indicating whether the authorization middleware checked that the user has permission to access the requested resource. Approved - True or false, indicating whether the user has permission to access the requested resource. Error - Describes any error that occurred during the authorization check. The authorization middleware will not let a request proceed unless the ResourceAuthorization object's Checked and Approved attrbutes are both true.","title":"Authorization"},{"location":"security/authorization/#things-to-note","text":"If, when adding a new endpoint, you to forget to define a permission for it, you will never be able to reach that endpoint, because without a defined permission, ResourceAuthorization.Checked will be false. Requests for list endpoints, such as the WorkItems list and the IntellectualObject list, cannot include a ResourceID or a ResourceInstID, because the requests don't target a single resource. Unless the requesting user is an APTrust admin, database queries issued by these requests will always include an Institution ID filter, with the ID set to the user's own institution ID. For example, when a user from virginia.edu requests a list of WorkItems, objects, or files, the system will force a where clause into their queries stating where institution_id = [user's institution id] . This occurs in the LoadResourceList() function of the Web UI's Request object and in the LoadResourceList() function of the API's Request object .","title":"Things to Note"},{"location":"security/authorization/#permission-definitions","text":"All of Registry's permission are defined in constants/permissions.go . The initPermissions() function in that file assigns permissions to roles like so: // Institutional User Role instUser [ ChecksumRead ] = true instUser [ DashboardShow ] = true // ... additional permissions omitted for brevity... // Institutional Admin Role instAdmin [ FileDelete ] = true instAdmin [ FileRead ] = true // ... additional permissions omitted for brevity... // Sys Admin Role sysAdmin [ ChecksumCreate ] = true sysAdmin [ ChecksumDelete ] = false // no one can do this sysAdmin [ ChecksumRead ] = true // ... additional permissions omitted for brevity... Registry permissions are role-based with the following general rules: Institutional Users can access resources belonging to their own institution, but cannot perform destructive actions and manipulate other user accounts. Institutional Admins can do everything Institutional Users can do, plus approve deletion requests and manipulate other user accounts at their own institution. The System Administrator account has all privileges at all institutions, plus some additional privileges such as creating, editing, and deactivating institutions, managing NSQ services, re-queueing WorkItems, and other administrative tasks. Important No role has any permission unless it is explicitly granted in constants/permissions.go , and some permissions are explicitly denied to all users because they violate business rules. For example, no user can delete checksums or delete or alter PREMIS events. The endpoints to perform these actions don't even exist, and the underlying data models will throw errors if anyone even tries to perform these actions.","title":"Permission Definitions"},{"location":"security/authorization/#permission-mapping","text":"While permissions are defined and assigned to roles in constants/permissions.go , they are mapped to request handlers in middleware/authorization_map.go . The authorization map tells the app which permission is required to access each request handler. Important If you don't map a permission to your new request handler, no one will be able to reach it, ever, because the authorization check will fail.","title":"Permission Mapping"},{"location":"security/authorization/#permission-checking","text":"The middleware/authorization.go middleware figures out which request handler responds to the current URL. It reads the authorization map to see which permission is required to access that handler, then determines whether the current user is allowed to call that handler. It also does further checks, as described above, to see if the user can access whatever resources that handler touches.","title":"Permission Checking"},{"location":"security/authorization/#list-of-authorization-related-files","text":"File Description constants/permissions.go Defines all of the system permissions and assigns them to roles at application start. middleware/authorization_map.go Maps permissions to web and API request handlers. middleware/authorize.go Authorizes requests and decides whether or not to pass the request on to the handler. middleware/resource_authorization.go Includes logic to compare user permissions to the authorization map, and to do fine-grained resource-level checks. (I.e. Ensures objects user is requesting actually belong to that user's institution.) web/webui/request.go Enforces filters in list requests to ensure users access only resources belonging to their own institution. web/api/request/go Enforces filters in API list requests to ensure users access only resources belonging to their own institution.","title":"List of Authorization-Related Files"},{"location":"security/csrf/","text":"Cross-Site Request Forgery","title":"Cross-Site Request Forgery"},{"location":"security/csrf/#cross-site-request-forgery","text":"","title":"Cross-Site Request Forgery"}]}